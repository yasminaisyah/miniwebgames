<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reaction Rush: Molecule Factory</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Righteous&family=Roboto+Mono:wght@500&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            font-family: 'Righteous', cursive;
            color: white;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            background: radial-gradient(circle at center, #333 0%, #111 100%);
        }

        /* The Conveyor Belts */
        #tracks-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            height: 100%;
            border-left: 5px solid #444;
            border-right: 5px solid #444;
            background: repeating-linear-gradient(
                0deg,
                #2a2a2a,
                #2a2a2a 40px,
                #222 40px,
                #222 80px
            );
            animation: scrollBackground 2s linear infinite;
            overflow: hidden;
        }

        @keyframes scrollBackground {
            from { background-position: 0 0; }
            to { background-position: 0 80px; }
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            font-size: 24px;
            text-shadow: 0 0 10px #000;
        }

        /* The Flask / Recipe Display */
        #recipe-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 4px solid #00d2d3;
            border-radius: 20px;
            padding: 15px 40px;
            text-align: center;
            box-shadow: 0 0 20px rgba(0, 210, 211, 0.3);
            width: 80%;
            max-width: 400px;
        }

        #target-name {
            font-size: 18px;
            color: #aaa;
            margin-bottom: 5px;
        }

        #target-formula {
            font-size: 40px;
            color: #fff;
            letter-spacing: 5px;
        }

        .collected-atom {
            display: inline-block;
            color: #00d2d3;
            text-shadow: 0 0 10px #00d2d3;
        }

        .missing-atom {
            display: inline-block;
            color: #555;
        }

        /* Start & Game Over Screens */
        #overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 20;
        }

        h1 {
            font-size: 50px;
            background: -webkit-linear-gradient(#ff9ff3, #feca57);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 0 0 20px 0;
        }

        p {
            font-family: 'Roboto Mono', monospace;
            font-size: 16px;
            color: #ccc;
            text-align: center;
            max-width: 500px;
            line-height: 1.6;
            margin-bottom: 40px;
        }

        button {
            padding: 15px 50px;
            font-family: 'Righteous', cursive;
            font-size: 24px;
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 6px 0 #c0392b;
            transition: all 0.1s;
        }

        button:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #c0392b;
        }

        .hidden { display: none !important; }

        /* Floating text animation */
        .float-text {
            position: absolute;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
        }

        @keyframes floatUp {
            from { opacity: 1; transform: translateY(0); }
            to { opacity: 0; transform: translateY(-50px); }
        }

    </style>
</head>
<body>

<div id="game-container">
    <div id="tracks-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div id="ui-layer">
        <div class="hud-top">
            <div id="score-el">SCORE: 0</div>
            <div id="level-el">LVL: 1</div>
        </div>
        
        <div id="recipe-panel">
            <div id="target-name">Preparing...</div>
            <div id="target-formula">H <span class="missing-atom">O</span> H</div>
        </div>
    </div>

    <div id="overlay-screen">
        <h1 id="screen-title">REACTION RUSH</h1>
        <p id="screen-desc">
            Welcome to the Molecular Factory.<br>
            Formulas will appear at the bottom (e.g., H₂O).<br>
            Tap the matching falling atoms to build the molecule.<br>
            Don't let the required atoms slip away!
        </p>
        <button id="action-btn">START ENGINE</button>
    </div>
</div>

<script>
/**
 * AUDIO SYSTEM (Synthesized)
 */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playSound(type) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    osc.connect(gainNode);
    gainNode.connect(audioCtx.destination);

    const now = audioCtx.currentTime;

    if (type === 'collect') {
        // Sci-fi bloop
        osc.type = 'sine';
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
        gainNode.gain.setValueAtTime(0.3, now);
        gainNode.gain.linearRampToValueAtTime(0, now + 0.1);
        osc.start();
        osc.stop(now + 0.1);
    } else if (type === 'complete') {
        // Success chord
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(440, now); // A4
        osc.frequency.setValueAtTime(554, now + 0.1); // C#5
        osc.frequency.setValueAtTime(659, now + 0.2); // E5
        gainNode.gain.setValueAtTime(0.2, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
        osc.start();
        osc.stop(now + 0.6);
    } else if (type === 'miss') {
        // Error buzzer
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.linearRampToValueAtTime(100, now + 0.2);
        gainNode.gain.setValueAtTime(0.3, now);
        gainNode.gain.linearRampToValueAtTime(0, now + 0.2);
        osc.start();
        osc.stop(now + 0.2);
    }
}

/**
 * CHEMISTRY DATA
 */
const RECIPES = [
    { name: "Water", formula: ["H", "H", "O"], display: "H₂O" },
    { name: "Salt", formula: ["Na", "Cl"], display: "NaCl" },
    { name: "Oxygen Gas", formula: ["O", "O"], display: "O₂" },
    { name: "Carbon Dioxide", formula: ["C", "O", "O"], display: "CO₂" },
    { name: "Methane", formula: ["C", "H", "H", "H", "H"], display: "CH₄" },
    { name: "Ammonia", formula: ["N", "H", "H", "H"], display: "NH₃" }
];

const ATOMS = {
    "H": { color: "#ffffff", border: "#999" },    // White
    "O": { color: "#ff6b6b", border: "#c0392b" }, // Red
    "C": { color: "#555555", border: "#222" },    // Black/Grey
    "N": { color: "#54a0ff", border: "#2e86de" }, // Blue
    "Na":{ color: "#a29bfe", border: "#6c5ce7" }, // Purple
    "Cl":{ color: "#1dd1a1", border: "#10ac84" }, // Green
    "He":{ color: "#feca57", border: "#ff9f43" }  // Yellow (Distraction)
};

/**
 * GAME ENGINE
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const tracksContainer = document.getElementById('tracks-container');

// UI Elements
const scoreEl = document.getElementById('score-el');
const levelEl = document.getElementById('level-el');
const targetNameEl = document.getElementById('target-name');
const targetFormulaEl = document.getElementById('target-formula');
const overlayScreen = document.getElementById('overlay-screen');
const screenTitle = document.getElementById('screen-title');
const screenDesc = document.getElementById('screen-desc');
const actionBtn = document.getElementById('action-btn');

let width, height;
let laneWidth;

// Game State
let gameState = 'MENU'; // MENU, PLAYING, GAMEOVER
let score = 0;
let level = 1;
let speed = 2;
let spawnRate = 60;
let frameCount = 0;
let items = [];
let particles = [];
let currentRecipe = null;
let collectedAtoms = []; // What we have collected for the current recipe

function resize() {
    width = tracksContainer.clientWidth;
    height = tracksContainer.clientHeight;
    canvas.width = width;
    canvas.height = height;
    laneWidth = width / 4;
}
window.addEventListener('resize', resize);
resize();

// --- Logic ---

function startNewRecipe() {
    // Pick random recipe based on level (simulated by just random for now)
    const r = RECIPES[Math.floor(Math.random() * RECIPES.length)];
    // Clone formula array so we can manipulate it if needed, though here we just reference
    currentRecipe = { ...r }; 
    collectedAtoms = [];
    updateRecipeUI();
}

function updateRecipeUI() {
    targetNameEl.innerText = "Building: " + currentRecipe.name.toUpperCase();
    
    // Build the visual formula
    // We want to show items collected in Color, and uncollected in Grey
    let html = "";
    
    // Create a copy of formula to check against collected
    let remainingNeeded = [...currentRecipe.formula];
    let displayList = [];

    // This logic handles duplicate atoms (like H in H2O) correctly
    // It's a bit tricky to map collected atoms to the formula visually order-wise
    // So we will just show the formula string, and light up characters?
    // Simpler approach for Kids UI: Just show slots.
    
    html = "";
    
    // Map required atoms
    let collectedCopy = [...collectedAtoms];
    
    currentRecipe.formula.forEach(atom => {
        const foundIndex = collectedCopy.indexOf(atom);
        if (foundIndex > -1) {
            // We have this atom
            html += `<span class="collected-atom" style="color:${ATOMS[atom].color}; margin:0 5px;">${atom}</span>`;
            collectedCopy.splice(foundIndex, 1); // remove so we don't count it twice
        } else {
            // Missing
            html += `<span class="missing-atom" style="margin:0 5px; opacity:0.3">${atom}</span>`;
        }
    });

    targetFormulaEl.innerHTML = html;
}

function spawnItem() {
    const lane = Math.floor(Math.random() * 4);
    const x = lane * laneWidth + laneWidth/2;
    
    // Decide what atom to spawn
    // High chance to spawn what is needed
    let type;
    const needed = currentRecipe.formula.filter(f => !collectedAtoms.includes(f)); // rough check, logic slightly flawed for duplicates but good enough for spawn rates
    
    if (Math.random() < 0.6 && needed.length > 0) {
        // Spawn something we need
        type = needed[Math.floor(Math.random() * needed.length)];
    } else {
        // Spawn random junk or distraction
        const keys = Object.keys(ATOMS);
        type = keys[Math.floor(Math.random() * keys.length)];
    }

    items.push({
        type: type,
        x: x,
        y: -50,
        r: 30, // radius
        lane: lane,
        active: true
    });
}

function createParticles(x, y, color) {
    for(let i=0; i<10; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 10,
            vy: (Math.random() - 0.5) * 10,
            life: 1,
            color: color
        });
    }
}

function showFloatText(text, x, y, color) {
    const el = document.createElement('div');
    el.className = 'float-text';
    el.innerText = text;
    el.style.left = x + 'px';
    el.style.top = y + 'px';
    el.style.color = color;
    document.getElementById('ui-layer').appendChild(el);
    setTimeout(() => el.remove(), 1000);
}

function checkCollection(atomType, x, y) {
    // Check if this atom is needed in the recipe
    // We need to count how many of this type are required vs how many we have
    const requiredCount = currentRecipe.formula.filter(a => a === atomType).length;
    const haveCount = collectedAtoms.filter(a => a === atomType).length;

    if (haveCount < requiredCount) {
        // Good! We need this.
        collectedAtoms.push(atomType);
        playSound('collect');
        createParticles(x, y, ATOMS[atomType].color);
        updateRecipeUI();
        
        // Check if recipe complete
        if (collectedAtoms.length === currentRecipe.formula.length) {
            // Formula Done!
            score += 100 + (level * 10);
            playSound('complete');
            showFloatText("COMPLETE!", width/2, height/2, "#fff");
            
            // Level up mechanics
            if (score % 300 === 0) {
                level++;
                speed += 0.5;
                spawnRate = Math.max(20, spawnRate - 5);
                showFloatText("SPEED UP!", width/2, height/2 - 50, "#ff9ff3");
            }
            
            scoreEl.innerText = "SCORE: " + score;
            levelEl.innerText = "LVL: " + level;
            
            setTimeout(startNewRecipe, 500); // Slight delay before next recipe
        }
        return true;
    } else {
        // Bad! We don't need this, or we already have enough.
        playSound('miss');
        score -= 10;
        showFloatText("-10", x, y, "#ff6b6b");
        scoreEl.innerText = "SCORE: " + score;
        return false; // Visual feedback handled by caller usually, but here we handled it
    }
}

// Interaction
function handleInput(clientX, clientY) {
    if (gameState !== 'PLAYING') return;

    // Correct coordinates relative to canvas
    const rect = canvas.getBoundingClientRect();
    const x = clientX - rect.left;
    const y = clientY - rect.top;

    // Check clicks on items
    for (let i = items.length - 1; i >= 0; i--) {
        let item = items[i];
        if (!item.active) continue;

        const dx = x - item.x;
        const dy = y - item.y;
        if (Math.sqrt(dx*dx + dy*dy) < item.r + 10) { // generous hitbox
            // Hit!
            const isGood = checkCollection(item.type, item.x, item.y);
            item.active = false; // Remove item whether good or bad click
            // If bad click, maybe shake screen?
        }
    }
}

canvas.addEventListener('mousedown', e => handleInput(e.clientX, e.clientY));
canvas.addEventListener('touchstart', e => {
    e.preventDefault(); // stop zoom
    handleInput(e.touches[0].clientX, e.touches[0].clientY);
}, {passive: false});

// Game Loop
function update() {
    if (gameState !== 'PLAYING') return;
    
    ctx.clearRect(0, 0, width, height);

    // Draw Lane Lines (Visual hint)
    ctx.strokeStyle = "rgba(255,255,255,0.05)";
    ctx.lineWidth = 2;
    for(let i=1; i<4; i++) {
        ctx.beginPath();
        ctx.moveTo(i*laneWidth, 0);
        ctx.lineTo(i*laneWidth, height);
        ctx.stroke();
    }

    // Spawn logic
    if (frameCount % Math.floor(spawnRate) === 0) {
        spawnItem();
    }

    // Update Items
    for (let i = items.length - 1; i >= 0; i--) {
        let item = items[i];
        if (!item.active) {
            items.splice(i, 1);
            continue;
        }

        item.y += speed;

        // Draw Item
        const data = ATOMS[item.type];
        
        // Glow
        ctx.shadowBlur = 15;
        ctx.shadowColor = data.color;
        
        // Circle
        ctx.fillStyle = data.color;
        ctx.beginPath();
        ctx.arc(item.x, item.y, item.r, 0, Math.PI*2);
        ctx.fill();

        // Border
        ctx.strokeStyle = data.border;
        ctx.lineWidth = 4;
        ctx.stroke();

        ctx.shadowBlur = 0;

        // Text
        ctx.fillStyle = "#222";
        ctx.font = "bold 24px Roboto Mono";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(item.type, item.x, item.y);

        // Missed Logic?
        // In this game, if you miss a needed atom, it just falls off.
        // You have to wait for another one.
        // But to make it challenging, maybe a "Missed Opportunities" counter?
        // For kids, let's keep it simple: Infinite chances, but speed makes it hard.
        if (item.y > height + 50) {
            item.active = false;
        }
    }

    // Update Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.05;
        
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;

        if (p.life <= 0) particles.splice(i, 1);
    }

    frameCount++;
    requestAnimationFrame(update);
}

// Controls
function startGame() {
    score = 0;
    level = 1;
    speed = 2;
    spawnRate = 60;
    items = [];
    particles = [];
    frameCount = 0;
    
    scoreEl.innerText = "SCORE: 0";
    levelEl.innerText = "LVL: 1";
    
    startNewRecipe();
    
    gameState = 'PLAYING';
    overlayScreen.classList.add('hidden');
    update();
}

actionBtn.addEventListener('click', () => {
    // Init Audio
    if (audioCtx.state === 'suspended') audioCtx.resume();
    startGame();
});

</script>
</body>
</html>