<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Factor Catcher</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Rajdhani:wght@500;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050510;
            font-family: 'Rajdhani', sans-serif;
            touch-action: none; /* Prevent zooming on mobile */
        }

        #game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* Top HUD */
        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
            font-size: 1.5rem;
            font-weight: bold;
        }

        /* Mission Display */
        .mission-box {
            position: absolute;
            top: 80px;
            width: 100%;
            text-align: center;
            pointer-events: none;
        }

        .mission-label {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            color: #ff00de;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .mission-text {
            font-size: 2.5rem;
            color: #fff;
            text-shadow: 0 0 20px #ff00de;
            font-weight: 700;
            background: rgba(0,0,0,0.5);
            display: inline-block;
            padding: 10px 30px;
            border-radius: 20px;
            border: 1px solid rgba(255, 0, 222, 0.3);
        }

        /* Start/Over Screens */
        .screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 16, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }

        .hidden { display: none !important; }

        h1 {
            font-family: 'Press Start 2P', cursive;
            color: #00ffff;
            font-size: 2rem;
            text-align: center;
            line-height: 1.5;
            margin-bottom: 20px;
            text-shadow: 4px 4px 0px #ff00de;
        }

        p { color: #ccc; font-size: 1.2rem; margin-bottom: 40px; text-align: center; max-width: 600px; }

        .btn {
            background: #ff00de;
            color: white;
            border: none;
            padding: 20px 50px;
            font-size: 1.5rem;
            font-family: 'Rajdhani', sans-serif;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 0 20px #ff00de;
            border-radius: 5px;
            transition: transform 0.1s;
        }
        .btn:hover { transform: scale(1.1); background: #ff44e5; }

        canvas { display: block; }

        /* Hearts */
        .lives { display: flex; gap: 10px; }
        .heart { width: 30px; height: 30px; background: #ff0055; clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%); }
        .heart.lost { background: #555; }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="game-ui">
        <div class="hud-top">
            <div>SCORE: <span id="score">0</span></div>
            <div class="lives" id="lives-container">
                <div class="heart"></div><div class="heart"></div><div class="heart"></div>
            </div>
        </div>
        
        <div class="mission-box">
            <div class="mission-label">CURRENT MISSION</div>
            <div class="mission-text" id="mission-text">LOADING...</div>
        </div>
    </div>

    <div id="start-screen" class="screen">
        <h1>COSMIC<br>FACTOR CATCHER</h1>
        <p>Use Mouse or Arrow Keys to move.<br>Catch the numbers that match the mission.<br>Avoid the rest!</p>
        <button class="btn" onclick="game.init()">LAUNCH SHIP</button>
    </div>

    <div id="game-over-screen" class="screen hidden">
        <h1 style="color:#ff0055; text-shadow: 4px 4px 0 #fff;">MISSION FAILED</h1>
        <p>Final Score: <span id="final-score" style="color:#fff; font-weight:bold;">0</span></p>
        <button class="btn" onclick="game.init()">RETRY MISSION</button>
    </div>

    <script>
        /**
         * Math Logic Helpers
         */
        const MathLib = {
            isPrime: (n) => {
                if (n <= 1) return false;
                for (let i = 2; i <= Math.sqrt(n); i++) if (n % i === 0) return false;
                return true;
            },
            getFactors: (n) => {
                let factors = [];
                for(let i=1; i<=n; i++) if(n%i===0) factors.push(i);
                return factors;
            },
            getPrimeFactors: (n) => {
                let factors = [];
                for(let i=1; i<=n; i++) if(n%i===0 && MathLib.isPrime(i)) factors.push(i);
                return factors;
            },
            // Generates a random integer between min and max (inclusive)
            rand: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min
        };

        /**
         * Game Engine
         */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Resize canvas to full window
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // Audio System
        const AudioSys = {
            ctx: new (window.AudioContext || window.webkitAudioContext)(),
            play(type) {
                if (this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                
                const now = this.ctx.currentTime;
                if(type === 'catch') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                } else if (type === 'hit') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(100, now);
                    osc.frequency.linearRampToValueAtTime(50, now + 0.3);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.3);
                    osc.start(now);
                    osc.stop(now + 0.3);
                }
            }
        };

        const Game = {
            active: false,
            score: 0,
            lives: 3,
            level: 1,
            player: { x: 0, width: 100, height: 20, speed: 0 },
            numbers: [],
            particles: [],
            lastTime: 0,
            spawnTimer: 0,
            missionDuration: 0,
            
            // Current Mission State
            currentRule: null, 
            ruleType: '', // 'prime', 'multiple', 'factor', 'common'
            targetValue: 0,
            secondaryValue: 0,

            init() {
                this.active = true;
                this.score = 0;
                this.lives = 3;
                this.level = 1;
                this.numbers = [];
                this.particles = [];
                this.player.x = canvas.width / 2 - this.player.width / 2;
                
                document.getElementById('start-screen').classList.add('hidden');
                document.getElementById('game-over-screen').classList.add('hidden');
                this.updateLivesUI();
                this.setNewMission();
                
                requestAnimationFrame(t => this.loop(t));
            },

            setNewMission() {
                // Clear existing numbers to be fair when rule changes
                // this.numbers = []; 
                
                const types = ['prime', 'multiple', 'factor', 'factor', 'prime_factor'];
                this.ruleType = types[MathLib.rand(0, types.length - 1)];
                
                const missionText = document.getElementById('mission-text');

                if (this.ruleType === 'prime') {
                    missionText.innerText = "Catch PRIME Numbers";
                } 
                else if (this.ruleType === 'multiple') {
                    this.targetValue = MathLib.rand(2, 9);
                    missionText.innerText = `Catch Multiples of ${this.targetValue}`;
                }
                else if (this.ruleType === 'factor') {
                    this.targetValue = MathLib.rand(12, 60);
                    missionText.innerText = `Catch Factors of ${this.targetValue}`;
                }
                else if (this.ruleType === 'prime_factor') {
                    this.targetValue = MathLib.rand(20, 100);
                    missionText.innerText = `Catch Prime Factors of ${this.targetValue}`;
                }

                // Flash animation for text
                missionText.style.transform = "scale(1.2)";
                setTimeout(() => missionText.style.transform = "scale(1)", 200);

                this.missionDuration = 1000; // Frames until next mission change
            },

            spawnNumber() {
                let val, isCorrect;
                const chance = Math.random();

                // 40% chance to spawn a correct answer
                if (chance < 0.4) {
                    isCorrect = true;
                    if (this.ruleType === 'prime') {
                        // Generate a prime
                        do { val = MathLib.rand(2, 50); } while (!MathLib.isPrime(val));
                    } 
                    else if (this.ruleType === 'multiple') {
                        val = this.targetValue * MathLib.rand(1, 10);
                    }
                    else if (this.ruleType === 'factor') {
                        const facts = MathLib.getFactors(this.targetValue);
                        val = facts[MathLib.rand(0, facts.length-1)];
                    }
                    else if (this.ruleType === 'prime_factor') {
                        const facts = MathLib.getPrimeFactors(this.targetValue);
                        if (facts.length > 0) val = facts[MathLib.rand(0, facts.length-1)];
                        else val = 2; // Fallback
                    }
                } else {
                    // Spawn a distractor
                    isCorrect = false;
                    val = MathLib.rand(2, 99);
                    // Ensure accidentally correct numbers are marked correct or regenerated
                    // For simplicity in arcade, we just check validity on creation:
                    if (this.checkValidity(val)) isCorrect = true; 
                }

                this.numbers.push({
                    x: MathLib.rand(20, canvas.width - 40),
                    y: -50,
                    val: val,
                    speed: MathLib.rand(2, 4) + (this.level * 0.5),
                    color: isCorrect ? '#fff' : '#aaa', // Visual clue? No, let them do math!
                    isTarget: isCorrect
                });
            },

            checkValidity(val) {
                if (this.ruleType === 'prime') return MathLib.isPrime(val);
                if (this.ruleType === 'multiple') return val % this.targetValue === 0;
                if (this.ruleType === 'factor') return this.targetValue % val === 0;
                if (this.ruleType === 'prime_factor') return this.targetValue % val === 0 && MathLib.isPrime(val);
                return false;
            },

            update(dt) {
                // Spawn Logic
                this.spawnTimer++;
                if (this.spawnTimer > 60 - (this.level * 2)) {
                    this.spawnNumber();
                    this.spawnTimer = 0;
                }

                // Mission Timer
                this.missionDuration--;
                if (this.missionDuration <= 0) this.setNewMission();

                // Player Movement
                // (Handled via mousemove event below, but we clamp here)
                if (this.player.x < 0) this.player.x = 0;
                if (this.player.x > canvas.width - this.player.width) this.player.x = canvas.width - this.player.width;

                // Numbers Logic
                for (let i = this.numbers.length - 1; i >= 0; i--) {
                    let n = this.numbers[i];
                    n.y += n.speed;

                    // Collision Check
                    if (
                        n.y + 30 > canvas.height - 60 && // Height of player area
                        n.y < canvas.height - 20 &&
                        n.x + 30 > this.player.x &&
                        n.x < this.player.x + this.player.width
                    ) {
                        // HIT
                        if (this.checkValidity(n.val)) {
                            // Correct
                            this.score += 10;
                            AudioSys.play('catch');
                            this.createParticles(n.x, n.y, '#00ff88');
                        } else {
                            // Wrong
                            this.lives--;
                            this.updateLivesUI();
                            AudioSys.play('hit');
                            this.createParticles(n.x, n.y, '#ff0055');
                            if (this.lives <= 0) this.gameOver();
                        }
                        this.numbers.splice(i, 1);
                        document.getElementById('score').innerText = this.score;
                        continue;
                    }

                    // Remove if off screen
                    if (n.y > canvas.height) {
                        this.numbers.splice(i, 1);
                    }
                }

                // Particle Logic
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    let p = this.particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.05;
                    if (p.life <= 0) this.particles.splice(i, 1);
                }

                // Level up
                this.level = 1 + Math.floor(this.score / 200);
            },

            draw() {
                // Clear
                ctx.fillStyle = 'rgba(5, 5, 16, 0.4)'; // Trail effect
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw Grid Effect
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.05)';
                ctx.lineWidth = 1;
                const gridSize = 50;
                const offset = (Date.now() / 50) % gridSize;
                ctx.beginPath();
                for (let i = 0; i < canvas.width; i+=gridSize) {
                    ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height);
                }
                for (let i = offset; i < canvas.height; i+=gridSize) {
                    ctx.moveTo(0, i); ctx.lineTo(canvas.width, i);
                }
                ctx.stroke();

                // Draw Player
                ctx.fillStyle = '#00ffff';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#00ffff';
                ctx.fillRect(this.player.x, canvas.height - 50, this.player.width, 20);
                // Engine flame
                ctx.fillStyle = `rgba(255, 0, 222, ${Math.random()})`;
                ctx.fillRect(this.player.x + 20, canvas.height - 30, 10, 20);
                ctx.fillRect(this.player.x + this.player.width - 30, canvas.height - 30, 10, 20);
                ctx.shadowBlur = 0;

                // Draw Numbers
                ctx.font = 'bold 30px "Rajdhani"';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                this.numbers.forEach(n => {
                    ctx.fillStyle = '#fff';
                    // ctx.fillStyle = n.isTarget ? '#0f0' : '#fff'; // Debug cheat
                    ctx.fillText(n.val, n.x + 15, n.y + 15);
                    
                    // Bubble around number
                    ctx.strokeStyle = this.checkValidity(n.val) ? 'rgba(0,255,136,0.5)' : 'rgba(255,255,255,0.2)';
                    ctx.beginPath();
                    ctx.arc(n.x + 15, n.y + 15, 25, 0, Math.PI*2);
                    ctx.stroke();
                });

                // Draw Particles
                this.particles.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                });
            },

            loop(time) {
                if (!this.active) return;
                const dt = time - this.lastTime;
                this.lastTime = time;

                this.update(dt);
                this.draw();
                requestAnimationFrame(t => this.loop(t));
            },

            createParticles(x, y, color) {
                for (let i = 0; i < 15; i++) {
                    this.particles.push({
                        x: x, y: y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        life: 1,
                        color: color,
                        size: Math.random() * 5
                    });
                }
            },

            updateLivesUI() {
                const container = document.getElementById('lives-container');
                container.innerHTML = '';
                for(let i=0; i<3; i++) {
                    const d = document.createElement('div');
                    d.className = i < this.lives ? 'heart' : 'heart lost';
                    container.appendChild(d);
                }
            },

            gameOver() {
                this.active = false;
                document.getElementById('final-score').innerText = this.score;
                document.getElementById('game-over-screen').classList.remove('hidden');
            }
        };

        const game = Game;

        // Controls
        window.addEventListener('mousemove', (e) => {
            if(game.active) game.player.x = e.clientX - game.player.width / 2;
        });
        
        window.addEventListener('touchmove', (e) => {
            if(game.active) {
                e.preventDefault();
                game.player.x = e.touches[0].clientX - game.player.width / 2;
            }
        }, {passive: false});

        window.addEventListener('keydown', (e) => {
            if(!game.active) return;
            const step = 40;
            if (e.key === 'ArrowLeft') game.player.x -= step;
            if (e.key === 'ArrowRight') game.player.x += step;
        });

    </script>
</body>
</html>