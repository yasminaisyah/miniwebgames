<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Estate Tycoon: Area & Perimeter</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=Roboto:wght@400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #2c3e50;
            font-family: 'Roboto', sans-serif;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle, #34495e 0%, #1abc9c 100%); /* Office wall color */
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Top HUD */
        #hud {
            width: 100%;
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            background: rgba(0,0,0,0.3);
            color: #fff;
            box-sizing: border-box;
            z-index: 10;
        }

        .stat-box {
            background: #fff;
            color: #2c3e50;
            padding: 10px 20px;
            border-radius: 50px;
            font-weight: bold;
            box-shadow: 0 4px 0 #bdc3c7;
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 120px;
        }

        /* Client Area */
        #client-zone {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            position: relative;
        }

        #client-avatar {
            width: 120px;
            height: 120px;
            background: #ecf0f1;
            border-radius: 50%;
            border: 5px solid #34495e;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3rem;
            margin-bottom: 20px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            position: relative;
        }

        #patience-bar-container {
            position: absolute;
            bottom: -20px;
            width: 100%;
            height: 8px;
            background: #bdc3c7;
            border-radius: 4px;
            overflow: hidden;
        }

        #patience-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #f1c40f, #2ecc71);
            transition: width 0.1s linear;
        }

        #speech-bubble {
            background: #fff;
            padding: 20px 40px;
            border-radius: 20px;
            font-size: 1.8rem;
            color: #2c3e50;
            position: relative;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            max-width: 80%;
            text-align: center;
            font-family: 'Playfair Display', serif;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        #speech-bubble::after {
            content: '';
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 15px 15px 0;
            border-style: solid;
            border-color: #fff transparent transparent transparent;
        }

        .highlight-req {
            color: #e74c3c;
            font-weight: bold;
            text-decoration: underline;
        }

        /* Desk / Blueprints Area */
        #desk-area {
            width: 100%;
            height: 45vh;
            background: #7f8c8d; /* Desk color */
            border-top: 10px solid #555;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 0 20px;
            box-sizing: border-box;
            box-shadow: 0 -10px 30px rgba(0,0,0,0.3);
        }

        .blueprint-card {
            background: #3498db; /* Blueprint Blue */
            width: 28%;
            max-width: 300px;
            height: 80%;
            border: 4px solid #fff;
            border-radius: 5px;
            cursor: pointer;
            position: relative;
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            background-image: 
                linear-gradient(rgba(255,255,255,0.2) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.2) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .blueprint-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 15px 30px rgba(0,0,0,0.3);
            border-color: #f1c40f;
        }

        .blueprint-canvas {
            width: 90%;
            height: 90%;
        }

        /* Screens */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(44, 62, 80, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .hidden { display: none !important; }

        h1 {
            font-family: 'Playfair Display', serif;
            font-size: 3.5rem;
            color: #f1c40f;
            margin-bottom: 10px;
            text-align: center;
        }

        p {
            color: #ecf0f1;
            font-size: 1.2rem;
            margin-bottom: 30px;
            text-align: center;
            max-width: 600px;
            line-height: 1.6;
        }

        button {
            padding: 15px 40px;
            font-size: 1.5rem;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 5px 0 #1e8449;
            transition: transform 0.1s;
        }

        button:active {
            transform: translateY(4px);
            box-shadow: 0 1px 0 #1e8449;
        }

        /* Floating Money Text */
        .floater {
            position: absolute;
            font-weight: bold;
            font-size: 2rem;
            color: #2ecc71;
            animation: floatUp 1s forwards;
            pointer-events: none;
            z-index: 50;
            text-shadow: 2px 2px 0 #000;
        }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-100px); }
        }

        @keyframes popIn {
            0% { transform: scale(0); }
            80% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

    </style>
</head>
<body>

<div id="game-container">
    
    <div id="hud">
        <div class="stat-box">üí∞ $<span id="moneyVal">0</span></div>
        <div class="stat-box">‚≠ê Level <span id="levelVal">1</span></div>
    </div>

    <div id="client-zone">
        <div id="client-avatar">
            üë§
            <div id="patience-bar-container">
                <div id="patience-bar"></div>
            </div>
        </div>
        <div id="speech-bubble">Loading request...</div>
    </div>

    <div id="desk-area">
        <div class="blueprint-card" onclick="checkAnswer(0)">
            <canvas id="bp0" class="blueprint-canvas"></canvas>
        </div>
        <div class="blueprint-card" onclick="checkAnswer(1)">
            <canvas id="bp1" class="blueprint-canvas"></canvas>
        </div>
        <div class="blueprint-card" onclick="checkAnswer(2)">
            <canvas id="bp2" class="blueprint-canvas"></canvas>
        </div>
    </div>

    <div id="start-screen" class="overlay">
        <h1>ESTATE TYCOON</h1>
        <p>Topic: Perimeter & Area (Chapter 10)<br><br>
        Clients want properties with specific math values.<br>
        <strong>1. Check the Request:</strong> "I need Area 24!"<br>
        <strong>2. Check the Blueprints:</strong> Calculate Area (LxW) or Perimeter (Add Sides).<br>
        <strong>3. Sell:</strong> Click the correct blueprint to make money!</p>
        <button onclick="startGame()">OPEN FOR BUSINESS</button>
    </div>

    <div id="game-over-screen" class="overlay hidden">
        <h1 style="color: #e74c3c;">BANKRUPT!</h1>
        <p>The client left in anger.<br>Total Earnings: $<span id="finalMoney">0</span></p>
        <button onclick="startGame()">TRY AGAIN</button>
    </div>

</div>

<script>
    const AudioSys = {
        ctx: null,
        init: function() {
            if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        },
        playChing: function() {
            if (!this.ctx) return;
            const t = this.ctx.currentTime;
            const o = this.ctx.createOscillator();
            const g = this.ctx.createGain();
            o.type = 'sine';
            o.frequency.setValueAtTime(1200, t);
            o.frequency.exponentialRampToValueAtTime(1800, t + 0.1);
            g.gain.setValueAtTime(0.2, t);
            g.gain.linearRampToValueAtTime(0, t + 0.5);
            o.connect(g);
            g.connect(this.ctx.destination);
            o.start();
            o.stop(t + 0.5);
        },
        playAngry: function() {
            if (!this.ctx) return;
            const t = this.ctx.currentTime;
            const o = this.ctx.createOscillator();
            const g = this.ctx.createGain();
            o.type = 'sawtooth';
            o.frequency.setValueAtTime(150, t);
            o.frequency.linearRampToValueAtTime(80, t + 0.4);
            g.gain.setValueAtTime(0.2, t);
            g.gain.linearRampToValueAtTime(0, t + 0.4);
            o.connect(g);
            g.connect(this.ctx.destination);
            o.start();
            o.stop(t + 0.4);
        }
    };

    let state = {
        active: false,
        level: 1,
        money: 0,
        patience: 100,
        maxPatience: 100,
        decayRate: 0.2,
        currentRequest: null, // { type: 'Area', val: 24 }
        options: [] // Array of shape objects
    };

    function generateProblem() {
        // Reset patience based on level
        state.maxPatience = Math.max(100 - (state.level * 5), 40); // Gets faster
        state.patience = 100;
        state.decayRate = 0.2 + (state.level * 0.05);

        // Decide type: Area or Perimeter
        const types = ['Area', 'Perimeter'];
        const type = types[Math.floor(Math.random() * types.length)];
        
        // Decide Shape Type: Rectangle (Lvl 1+), Square (Lvl 1+), Triangle (Lvl 3+)
        // For simplicity and screen space, we mostly use Rectangles/Squares.
        // We add Triangles at Level 3.
        
        let shapeType = 'rect';
        if (state.level >= 3 && Math.random() > 0.6) shapeType = 'tri';

        // Generate Target Value
        // We work backwards. Create a shape, calc its value, set that as target.
        let targetShape = createRandomShape(shapeType);
        let targetVal = (type === 'Area') ? targetShape.area : targetShape.perimeter;

        // Generate 2 wrong options (distractors)
        // Ensure they don't accidentally match the target val
        let distractors = [];
        while(distractors.length < 2) {
            let s = createRandomShape(shapeType); // Use same shape type for consistency or mix? Mix is harder. Let's use same type to keep it fair visually.
            // Actually mixing is fine.
            let val = (type === 'Area') ? s.area : s.perimeter;
            if (val !== targetVal) {
                distractors.push(s);
            }
        }

        // Shuffle options
        state.options = [targetShape, ...distractors];
        state.options.sort(() => Math.random() - 0.5);

        state.currentRequest = { type: type, val: targetVal, shapeType: shapeType };
        
        // UI Update
        const unit = (type === 'Area') ? "m¬≤" : "m";
        document.getElementById('speech-bubble').innerHTML = `I'm looking for a property with <br><span class="highlight-req">${type}: ${targetVal}${unit}</span>`;
        
        // Draw Blueprints
        drawBlueprint('bp0', state.options[0]);
        drawBlueprint('bp1', state.options[1]);
        drawBlueprint('bp2', state.options[2]);
    }

    function createRandomShape(type) {
        if (type === 'rect') {
            const w = Math.floor(Math.random() * 8) + 2; // 2-10
            const h = Math.floor(Math.random() * 8) + 2;
            return {
                type: 'rect',
                w: w,
                h: h,
                area: w * h,
                perimeter: 2 * (w + h),
                labelW: `${w}m`,
                labelH: `${h}m`
            };
        } else {
            // Right-angled triangle for ease of drawing and area calc
            const b = (Math.floor(Math.random() * 4) + 2) * 2; // Even number base 4-10
            const h = Math.floor(Math.random() * 6) + 3; // 3-9
            const hyp = Math.round(Math.sqrt(b*b + h*h)); // Approx hypotenuse for perimeter
            return {
                type: 'tri',
                b: b,
                h: h,
                hyp: hyp,
                area: 0.5 * b * h,
                perimeter: b + h + hyp,
                labelB: `${b}m`,
                labelH: `${h}m`,
                labelHyp: `${hyp}m`
            };
        }
    }

    function drawBlueprint(canvasId, shape) {
        const c = document.getElementById(canvasId);
        const ctx = c.getContext('2d');
        
        // Handle HiDPI scaling
        const dpr = window.devicePixelRatio || 1;
        const rect = c.getBoundingClientRect();
        c.width = rect.width * dpr;
        c.height = rect.height * dpr;
        ctx.scale(dpr, dpr);

        ctx.clearRect(0, 0, rect.width, rect.height);
        
        // Draw Grid Background
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 1;
        const gridSize = 20;
        ctx.beginPath();
        for(let x=0; x<rect.width; x+=gridSize) { ctx.moveTo(x,0); ctx.lineTo(x,rect.height); }
        for(let y=0; y<rect.height; y+=gridSize) { ctx.moveTo(0,y); ctx.lineTo(rect.width,y); }
        ctx.stroke();

        ctx.strokeStyle = '#fff';
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        ctx.lineWidth = 3;
        const cx = rect.width / 2;
        const cy = rect.height / 2;
        const scale = 15; // Pixels per meter unit

        if (shape.type === 'rect') {
            const dw = shape.w * scale;
            const dh = shape.h * scale;
            const x = cx - dw/2;
            const y = cy - dh/2;
            
            ctx.beginPath();
            ctx.rect(x, y, dw, dh);
            ctx.fill();
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Roboto';
            ctx.textAlign = 'center';
            // Width Label (Top)
            ctx.fillText(shape.labelW, cx, y - 10);
            // Height Label (Right)
            ctx.fillText(shape.labelH, x + dw + 20, cy + dh/2);
        } 
        else if (shape.type === 'tri') {
            const db = shape.b * scale;
            const dh = shape.h * scale;
            const x = cx - db/2;
            const y = cy + dh/2; // Bottom Left Corner

            ctx.beginPath();
            ctx.moveTo(x, y); // Bottom Left
            ctx.lineTo(x + db, y); // Bottom Right
            ctx.lineTo(x, y - dh); // Top Left (Right Angle)
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Roboto';
            ctx.textAlign = 'center';
            // Height
            ctx.fillText(shape.labelH, x - 20, cy);
            // Base
            ctx.fillText(shape.labelB, cx, y + 20);
            // Hypotenuse
            ctx.fillText(shape.labelHyp, x + db/2 + 10, cy - dh/2);
        }
    }

    function checkAnswer(idx) {
        if (!state.active) return;

        const selected = state.options[idx];
        const reqVal = state.currentRequest.val;
        const reqType = state.currentRequest.type;
        
        let selectedVal = (reqType === 'Area') ? selected.area : selected.perimeter;

        if (selectedVal === reqVal) {
            // Correct
            const earnings = 100 + (state.level * 50) + Math.floor(state.patience);
            state.money += earnings;
            state.level++;
            
            AudioSys.playChing();
            showFloater(`+$${earnings}`, '#2ecc71');
            
            // Visual feedback
            document.getElementById('moneyVal').innerText = state.money;
            document.getElementById('levelVal').innerText = state.level;

            generateProblem();
        } else {
            // Wrong
            state.patience -= 30; // Big penalty
            AudioSys.playAngry();
            showFloater("WRONG!", "#e74c3c");
            // Flash screen red
            document.body.style.backgroundColor = "#e74c3c";
            setTimeout(() => document.body.style.backgroundColor = "#2c3e50", 100);
        }
    }

    function showFloater(text, color) {
        const el = document.createElement('div');
        el.className = 'floater';
        el.innerText = text;
        el.style.color = color;
        // Random position near center
        el.style.left = (window.innerWidth/2 - 50 + Math.random()*100) + 'px';
        el.style.top = (window.innerHeight/2 - 100) + 'px';
        document.body.appendChild(el);
        setTimeout(() => el.remove(), 1000);
    }

    function gameLoop() {
        if (!state.active) return;

        // Decrease patience
        state.patience -= state.decayRate;
        
        // Update Bar
        const bar = document.getElementById('patience-bar');
        const pct = (state.patience / 100) * 100;
        bar.style.width = Math.max(0, pct) + "%";
        
        // Color logic
        if (pct > 60) bar.style.background = "#2ecc71"; // Green
        else if (pct > 30) bar.style.background = "#f1c40f"; // Yellow
        else bar.style.background = "#e74c3c"; // Red

        if (state.patience <= 0) {
            gameOver();
        }

        requestAnimationFrame(gameLoop);
    }

    function startGame() {
        AudioSys.init();
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        
        state.active = true;
        state.money = 0;
        state.level = 1;
        state.patience = 100;
        
        document.getElementById('moneyVal').innerText = "0";
        document.getElementById('levelVal').innerText = "1";
        
        generateProblem();
        gameLoop();
    }

    function gameOver() {
        state.active = false;
        AudioSys.playAngry();
        document.getElementById('finalMoney').innerText = state.money;
        document.getElementById('game-over-screen').classList.remove('hidden');
    }

</script>
</body>
</html>