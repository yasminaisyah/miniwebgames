<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Angle Architect: Blueprint Mode</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Teko:wght@400;600&family=Courier+Prime&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #001a33; /* Blueprint Blue */
            font-family: 'Courier Prime', monospace;
            color: #e6f2ff;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-image: 
                linear-gradient(rgba(255,255,255,0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.1) 1px, transparent 1px);
            background-size: 50px 50px;
        }

        canvas {
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            background: rgba(0, 30, 60, 0.8);
            border: 4px solid #fff;
            border-radius: 4px;
        }

        /* UI Layer */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        /* Top HUD */
        #header {
            text-align: center;
            background: #000000aa;
            padding: 15px;
            border: 2px solid #fff;
            pointer-events: auto;
            max-width: 600px;
            margin: 0 auto;
        }

        h1 {
            margin: 0;
            font-family: 'Teko', sans-serif;
            font-size: 2.5rem;
            letter-spacing: 2px;
            color: #ffcc00;
            text-transform: uppercase;
        }

        #instruction {
            font-size: 1.2rem;
            color: #fff;
            margin-top: 10px;
        }

        #angle-readout {
            font-size: 2rem;
            color: #00ffcc;
            font-weight: bold;
            margin-top: 5px;
        }

        /* Bottom Controls */
        #controls {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
            gap: 15px;
        }

        /* Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none;
            width: 80%;
            max-width: 500px;
            height: 15px;
            background: #fff;
            border-radius: 5px;
            outline: none;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 30px;
            height: 30px;
            background: #ffcc00;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #000;
        }

        button {
            padding: 15px 50px;
            font-size: 1.5rem;
            font-family: 'Teko', sans-serif;
            background: #00ffcc;
            color: #000;
            border: 4px solid #000;
            cursor: pointer;
            box-shadow: 5px 5px 0 #000;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        button:active {
            transform: translate(2px, 2px);
            box-shadow: 3px 3px 0 #000;
        }

        button:disabled {
            background: #555;
            color: #888;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* Popups */
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 26, 51, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            pointer-events: auto;
        }

        .hidden { display: none !important; }

        .big-msg {
            font-family: 'Teko', sans-serif;
            font-size: 4rem;
            color: #fff;
            text-shadow: 5px 5px 0 #000;
            margin-bottom: 20px;
        }

        /* Stats */
        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="stats">
            <div>Level: <span id="levelVal">1</span></div>
            <div>Score: <span id="scoreVal">0</span></div>
        </div>

        <div id="header">
            <h1 id="level-title">PROJECT 1</h1>
            <div id="instruction">Rotate the Yellow Line to make x = 60°</div>
            <div id="angle-readout">Current: 0°</div>
        </div>

        <div id="controls">
            <input type="range" id="angleSlider" min="0" max="180" value="90">
            <button id="constructBtn" onclick="checkAnswer()">CONSTRUCT</button>
        </div>
    </div>

    <div id="overlay">
        <div class="big-msg" style="color:#ffcc00">ANGLE ARCHITECT</div>
        <p style="text-align:center; max-width:600px; font-size:1.2rem; margin-bottom:40px;">
            The city blueprints are incomplete.<br>
            We need you to rotate the <strong>Structural Beams</strong> (Yellow Lines) 
            to match the geometric requirements.<br><br>
            Use the Slider to rotate. Click Construct to build.
        </p>
        <button onclick="startGame()">OPEN BLUEPRINT</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Audio Context
    const AudioSys = {
        ctx: null,
        init: function() {
            if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        },
        playSuccess: function() {
            if (!this.ctx) return;
            const t = this.ctx.currentTime;
            const o = this.ctx.createOscillator();
            const g = this.ctx.createGain();
            o.type = 'triangle';
            o.frequency.setValueAtTime(440, t);
            o.frequency.setValueAtTime(880, t + 0.1);
            g.gain.setValueAtTime(0.1, t);
            g.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
            o.connect(g);
            g.connect(this.ctx.destination);
            o.start();
            o.stop(t + 0.3);
        },
        playFail: function() {
            if (!this.ctx) return;
            const t = this.ctx.currentTime;
            const o = this.ctx.createOscillator();
            const g = this.ctx.createGain();
            o.type = 'sawtooth';
            o.frequency.setValueAtTime(150, t);
            o.frequency.linearRampToValueAtTime(100, t + 0.3);
            g.gain.setValueAtTime(0.1, t);
            g.gain.linearRampToValueAtTime(0, t + 0.3);
            o.connect(g);
            g.connect(this.ctx.destination);
            o.start();
            o.stop(t + 0.3);
        },
        playTick: function() {
             // Optional mechanical click sound
        }
    };

    let state = {
        level: 1,
        score: 0,
        targetAngle: 0,
        currentAngle: 90,
        problemType: '', // 'X', 'Z', 'F', 'U'
        fixedLineAngle: 0,
        isParallel: false,
        solved: false
    };

    function resize() {
        canvas.width = window.innerWidth * 0.9;
        canvas.height = window.innerHeight * 0.7; // Keep room for UI
    }
    window.addEventListener('resize', resize);
    resize();

    // Slider Input
    const slider = document.getElementById('angleSlider');
    slider.addEventListener('input', (e) => {
        state.currentAngle = parseInt(e.target.value);
        updateReadout();
        draw();
    });

    function updateReadout() {
        // Calculate the "Measurement" based on problem type logic
        // But for UI simplicity, we show the slider value raw, 
        // and visually match it on canvas.
        // Actually, better UX: Show the specific angle 'x' being measured.
        
        let measured = calculateMeasuredAngle();
        document.getElementById('angle-readout').innerText = `Angle x: ${measured}°`;
        
        // Color feedback hint
        const diff = Math.abs(measured - state.targetAngle);
        if (diff < 3) document.getElementById('angle-readout').style.color = "#0f0";
        else document.getElementById('angle-readout').style.color = "#00ffcc";
    }

    function calculateMeasuredAngle() {
        // This function determines what value 'x' currently has based on the slider
        // The slider controls the slope of the Transversal (Yellow Line)
        
        // Let's normalize: Slider 0-180 represents the angle of the Yellow Line relative to the horizontal.
        let lineAng = state.currentAngle;
        
        // Problem specific logic to derive 'x' from lineAng
        // We will simplify visual logic:
        // If type Z (Alternate), x is the angle between Yellow and Horizontal.
        // If type U (Interior), x is same.
        
        // For simplicity in this game: The slider DIRECTLY controls 'x'.
        // We then draw the line at the angle that CREATES that 'x'.
        // This makes the game intuitive: "I need 60, I slide to 60".
        
        return state.currentAngle;
    }

    function generateLevel() {
        state.solved = false;
        document.getElementById('constructBtn').disabled = false;
        document.getElementById('constructBtn').innerText = "CONSTRUCT";
        document.getElementById('constructBtn').style.background = "#00ffcc";
        
        const types = ['X', 'Z', 'F', 'U'];
        // unlock types
        let available = ['X'];
        if (state.level > 1) available.push('Z'); // Parallel starts level 2
        if (state.level > 3) available.push('F');
        if (state.level > 5) available.push('U');
        
        state.problemType = available[Math.floor(Math.random() * available.length)];
        
        let target = 0;
        let title = "";
        let instr = "";

        if (state.problemType === 'X') {
            // Vertically Opposite / Intersecting
            state.isParallel = false;
            state.fixedLineAngle = 0; // Horizontal white line
            target = Math.floor(Math.random() * 80) + 40; // 40-120
            title = "INTERSECTING LINES";
            instr = `Set the Vertically Opposite Angle x to ${target}°`;
        }
        else if (state.problemType === 'Z') {
            state.isParallel = true;
            target = Math.floor(Math.random() * 80) + 30;
            title = "PARALLEL LINES (Z-SHAPE)";
            instr = `Set the Alternate Angle x to ${target}°`;
        }
        else if (state.problemType === 'F') {
            state.isParallel = true;
            target = Math.floor(Math.random() * 80) + 30;
            title = "PARALLEL LINES (F-SHAPE)";
            instr = `Set the Corresponding Angle x to ${target}°`;
        }
        else if (state.problemType === 'U') {
            state.isParallel = true;
            // Interior angles add to 180.
            // We give one angle (e.g., 120), ask user to set x to make it valid.
            // Target is the solution (e.g. 60).
            let given = Math.floor(Math.random() * 60) + 90; // 90-150
            target = 180 - given;
            title = "PARALLEL LINES (U-SHAPE)";
            instr = `Given <a>${given}°</a>, set Interior Angle x to match (Sum = 180°)`;
            state.givenAngle = given;
        }

        state.targetAngle = target;
        document.getElementById('level-title').innerText = title;
        document.getElementById('instruction').innerHTML = instr;

        // Randomize slider start
        let startVal = Math.floor(Math.random() * 160) + 10;
        // Ensure not too close
        if (Math.abs(startVal - target) < 20) startVal = (startVal + 50) % 180;
        
        slider.value = startVal;
        state.currentAngle = startVal;
        
        updateReadout();
        draw();
    }

    function draw() {
        // Clear
        ctx.fillStyle = '#001a33'; // Blueprint blue
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Grid Lines
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.lineWidth = 1;
        const gridSize = 40;
        ctx.beginPath();
        for(let x=0; x<canvas.width; x+=gridSize) { ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); }
        for(let y=0; y<canvas.height; y+=gridSize) { ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); }
        ctx.stroke();

        const cx = canvas.width / 2;
        const cy = canvas.height / 2;

        ctx.lineCap = 'round';

        // 1. Draw Fixed Lines (White)
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 4;
        
        if (state.isParallel) {
            // Draw two horizontal parallel lines
            ctx.beginPath();
            ctx.moveTo(cx - 300, cy - 80); ctx.lineTo(cx + 300, cy - 80);
            ctx.moveTo(cx - 300, cy + 80); ctx.lineTo(cx + 300, cy + 80);
            ctx.stroke();
            
            // Parallel Markers (Arrows)
            drawArrow(ctx, cx + 200, cy - 80);
            drawArrow(ctx, cx + 200, cy + 80);
        } else {
            // Intersecting single line horizontal
            ctx.beginPath();
            ctx.moveTo(cx - 300, cy); ctx.lineTo(cx + 300, cy);
            ctx.stroke();
        }

        // 2. Draw Transversal / Active Line (Yellow) based on Slider 'x'
        // We need to map 'x' (slider) to actual rotation in radians
        // For standard math visualization:
        // If x is acute angle with horizontal, line slope is x.
        
        let angleRad = state.currentAngle * (Math.PI / 180);
        
        // Calculate Line Endpoints
        // Length 500
        // Center is cx,cy
        // If angle is 0, line is horizontal. If 90, vertical.
        // NOTE: Canvas Y is inverted.
        
        // Visual Adjustment:
        // For Z/F/U/X, usually 'x' is the angle off the horizontal.
        // So we draw line at angle = -angleRad (to go up-right)
        
        let dx = Math.cos(-angleRad) * 300;
        let dy = Math.sin(-angleRad) * 300;
        
        ctx.strokeStyle = '#ffcc00'; // Construction Yellow
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(cx - dx, cy - dy);
        ctx.lineTo(cx + dx, cy + dy);
        ctx.stroke();

        // 3. Draw Angle Arcs and Labels
        drawAngleViz(cx, cy, angleRad);
    }

    function drawAngleViz(cx, cy, angleRad) {
        // This function draws the specific arc 'x' that the user is trying to match
        ctx.strokeStyle = '#00ffcc';
        ctx.lineWidth = 2;
        ctx.fillStyle = 'rgba(0, 255, 204, 0.2)';
        
        const r = 60; // Arc radius

        if (state.problemType === 'X') {
            // Draw arc for vertically opposite
            // Angle between Yellow (active) and White (flat)
            // Left side / Right side logic
            ctx.beginPath();
            // Draw arc from 0 to -angleRad
            ctx.arc(cx, cy, r, -angleRad, 0); 
            ctx.stroke();
            ctx.fill();
            
            // Label
            ctx.fillStyle = '#fff';
            ctx.font = '20px Courier Prime';
            ctx.fillText("x", cx + r + 10, cy - 20);
            
            // Draw Opposite Arc
            ctx.beginPath();
            ctx.arc(cx, cy, r, Math.PI - angleRad, Math.PI);
            ctx.stroke();
            ctx.fillStyle = 'rgba(0, 255, 204, 0.2)';
            ctx.fill();
            // Label Value (this is the one slider controls)
            // Actually, for X, both are x.
        }
        else if (state.problemType === 'Z') {
            // Alternate Interior
            // 1. Top Intersection: (cx + offset, cy - 80)
            // 2. Bottom Intersection: (cx - offset, cy + 80)
            // Line equation: y = mx. 
            // We need to find where line hits y = -80 and y = +80
            
            // Slope m = tan(-angleRad)
            // y = tan(-angle) * x  => x = y / tan(-angle)
            
            let tan = Math.tan(-angleRad);
            // Protect against div by zero
            if (Math.abs(tan) < 0.01) tan = 0.01;
            
            let topX = -80 / tan; 
            let botX = 80 / tan;
            
            // Draw Z shape highlights? No, just the angles.
            
            // Bottom Left Angle (Active)
            ctx.beginPath();
            ctx.arc(cx + botX, cy + 80, r, Math.PI, Math.PI - angleRad);
            ctx.stroke();
            ctx.fill();
            
            ctx.fillStyle = '#fff';
            ctx.fillText("x", cx + botX - 40, cy + 60);

            // Top Right Angle (Matching)
            ctx.beginPath();
            ctx.arc(cx + topX, cy - 80, r, -angleRad, 0); 
            ctx.stroke();
            ctx.fill();
            // Label the target value here so they know what to match
            // "Match this"
            ctx.fillStyle = '#ffcc00';
            ctx.fillText(state.targetAngle + "°", cx + topX + 20, cy - 60);
        }
        else if (state.problemType === 'F') {
            // Corresponding
             let tan = Math.tan(-angleRad);
             if (Math.abs(tan) < 0.01) tan = 0.01;
             let topX = -80 / tan; 
             let botX = 80 / tan;

             // Top Right Angle (Above parallel)
             ctx.beginPath();
             ctx.arc(cx + topX, cy - 80, r, -angleRad, 0);
             ctx.stroke();
             ctx.fill();
             ctx.fillStyle = '#ffcc00';
             ctx.fillText(state.targetAngle + "°", cx + topX + 20, cy - 60);

             // Bottom Right Angle (Above parallel) -> Corresponding
             ctx.beginPath();
             ctx.arc(cx + botX, cy + 80, r, -angleRad, 0);
             ctx.stroke();
             ctx.fill();
             ctx.fillStyle = '#fff';
             ctx.fillText("x", cx + botX + 20, cy + 60);
        }
        else if (state.problemType === 'U') {
             let tan = Math.tan(-angleRad);
             if (Math.abs(tan) < 0.01) tan = 0.01;
             let topX = -80 / tan; 
             let botX = 80 / tan;

             // Interior Top Right
             // Angle is 180 - x
             // Draw arc from PI to PI-angleRad? No.
             // Top line is flat. Transversal cuts.
             // Interior angle is between transversal and parallel line Inside.
             
             // Let's keep it simple: Top Right Interior
             ctx.beginPath();
             ctx.arc(cx + topX, cy - 80, r, 0, Math.PI - angleRad + Math.PI /* complex geometry math fix */); 
             // Simplified: Arc from 0 down to line?
             // Actually, arc from line (angle) down to horizontal (0)? No.
             // It's the obtuse angle usually if x is acute.
             
             // Draw Given
             ctx.beginPath();
             ctx.arc(cx + topX, cy - 80, 40, 0, Math.PI); // Half circle? No.
             // Just text for U type to simplify rendering
             ctx.fillStyle = '#ffcc00';
             ctx.fillText(state.givenAngle + "°", cx + topX + 10, cy - 50);

             // Bottom Right Interior (x)
             ctx.beginPath();
             ctx.arc(cx + botX, cy + 80, r, -angleRad, 0); // Approx
             ctx.stroke();
             ctx.fill();
             ctx.fillStyle = '#fff';
             ctx.fillText("x", cx + botX + 20, cy + 60);
        }
    }

    function drawArrow(ctx, x, y) {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x-10, y-10);
        ctx.lineTo(x-10, y+10);
        ctx.fill();
    }

    function checkAnswer() {
        if(state.solved) return;

        const diff = Math.abs(state.currentAngle - state.targetAngle);
        
        if (diff <= 3) {
            // SUCCESS
            state.solved = true;
            state.score += 100;
            AudioSys.playSuccess();
            
            // Visual feedback
            document.getElementById('constructBtn').innerText = "BUILT!";
            document.getElementById('constructBtn').style.background = "#0f0";
            document.getElementById('constructBtn').disabled = true;
            
            // Confetti or particle effect
            ctx.fillStyle = '#0f0';
            ctx.font = 'bold 60px Teko';
            ctx.fillText("BLUEPRINT APPROVED", canvas.width/2 - 200, canvas.height/2);
            
            setTimeout(() => {
                state.level++;
                document.getElementById('levelVal').innerText = state.level;
                document.getElementById('scoreVal').innerText = state.score;
                generateLevel();
            }, 2000);
        } else {
            // FAIL
            AudioSys.playFail();
            document.getElementById('constructBtn').innerText = "ERROR";
            document.getElementById('constructBtn').style.background = "#f00";
            setTimeout(() => {
                document.getElementById('constructBtn').innerText = "CONSTRUCT";
                document.getElementById('constructBtn').style.background = "#00ffcc";
            }, 500);
        }
    }

    function startGame() {
        AudioSys.init();
        document.getElementById('overlay').classList.add('hidden');
        generateLevel();
    }
</script>
</body>
</html>