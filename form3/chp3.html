<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asset Defense: The Interest Wars</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;700&display=swap');

        body {
            margin: 0;
            background-color: #050505;
            font-family: 'Chakra Petch', sans-serif;
            color: white;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            background: #111;
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.2);
            border: 2px solid #333;
        }

        /* --- UI LAYER --- */
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
        }

        /* STATS BAR */
        #stats-bar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            background: rgba(0,0,0,0.8);
            padding: 10px 30px;
            border-radius: 10px;
            border: 1px solid #444;
            pointer-events: auto;
        }

        .stat {
            text-align: center;
        }
        .stat-label { font-size: 0.8rem; color: #888; text-transform: uppercase; }
        .stat-val { font-size: 1.5rem; font-weight: bold; }
        #money-val { color: #00ff88; }
        #lives-val { color: #ff3333; }
        #wave-val { color: #00ccff; }
        #debt-val { color: #ff5555; }

        /* INTEREST TIMER */
        #interest-box {
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(0, 40, 20, 0.9);
            border: 2px solid #00ff88;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            width: 180px;
            pointer-events: auto;
        }
        .int-title { color: #00ff88; font-weight: bold; margin-bottom: 5px; }
        .int-timer { font-size: 2rem; font-weight: bold; }
        .int-desc { font-size: 0.8rem; color: #aaa; margin-top: 5px; }

        /* BUILD MENU */
        #build-menu {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            pointer-events: auto;
        }

        .tower-card {
            background: #222;
            border: 2px solid #555;
            padding: 10px;
            width: 100px;
            text-align: center;
            cursor: pointer;
            transition: 0.2s;
            position: relative;
        }
        .tower-card:hover { transform: translateY(-5px); border-color: #fff; }
        .tower-card.selected { border-color: #00ff88; background: #003311; }
        
        .t-name { font-weight: bold; font-size: 0.9rem; margin-bottom: 5px; }
        .t-cost { color: #00ff88; font-weight: bold; }
        .t-desc { font-size: 0.7rem; color: #aaa; margin-top: 5px; }

        /* LOAN BUTTON */
        #loan-btn {
            background: #300;
            border-color: #f00;
        }
        #loan-btn:hover { background: #500; }

        /* SCREENS */
        .screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
        }
        .hidden { display: none !important; }

        h1 { color: #00ff88; font-size: 3rem; margin-bottom: 10px; }
        p { max-width: 500px; text-align: center; color: #ccc; line-height: 1.5; margin-bottom: 30px; }
        
        button.start-btn {
            background: #00ff88; color: #000; border: none;
            padding: 15px 40px; font-size: 1.5rem; font-weight: bold;
            font-family: 'Chakra Petch'; cursor: pointer;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.4);
        }
        button.start-btn:hover { background: #fff; }

        /* Floating Text */
        .floater {
            position: absolute;
            font-weight: bold;
            pointer-events: none;
            animation: floatUp 1s forwards;
            text-shadow: 1px 1px 0 #000;
        }
        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-30px); opacity: 0; }
        }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="stats-bar">
            <div class="stat">
                <div class="stat-label">Cash</div>
                <div class="stat-val" id="money-val">$400</div>
            </div>
            <div class="stat">
                <div class="stat-label">Net Worth</div>
                <div class="stat-val" id="lives-val">20</div>
            </div>
            <div class="stat">
                <div class="stat-label">Wave</div>
                <div class="stat-val" id="wave-val">1</div>
            </div>
            <div class="stat">
                <div class="stat-label">Debt</div>
                <div class="stat-val" id="debt-val">$0</div>
            </div>
        </div>

        <div id="interest-box">
            <div class="int-title">COMPOUND INTEREST</div>
            <div class="int-timer" id="int-timer">5.0s</div>
            <div class="int-desc">Earn +5% on current cash!<br>Don't spend it all!</div>
        </div>

        <div id="build-menu">
            <div class="tower-card" onclick="selectTower(0)" id="btn-t0">
                <div class="t-name">SAVINGS TURRET</div>
                <div class="t-cost">$100</div>
                <div class="t-desc">Low Cost<br>Fast Fire</div>
            </div>
            <div class="tower-card" onclick="selectTower(1)" id="btn-t1">
                <div class="t-name">STOCK LASER</div>
                <div class="t-cost">$300</div>
                <div class="t-desc">High Dmg<br>Long Range</div>
            </div>
            <div class="tower-card" id="loan-btn" onclick="takeLoan()">
                <div class="t-name" style="color:#f55">TAKE LOAN</div>
                <div class="t-cost">+$500</div>
                <div class="t-desc">Cost: $2/sec<br>Interest!</div>
            </div>
             <div class="tower-card" onclick="payDebt()" style="background:#442222; border-color:#f55">
                <div class="t-name">PAY DEBT</div>
                <div class="t-cost">-$100</div>
                <div class="t-desc">Reduce Interest</div>
            </div>
        </div>
    </div>

    <div id="start-screen" class="screen">
        <h1>ASSET DEFENSE</h1>
        <p><strong>Topic: Savings, Investment & Debt</strong><br><br>
        1. <strong>Interest:</strong> Every 5 seconds, you earn 5% on your CASH. Holding money is a strategy!<br>
        2. <strong>Towers:</strong> Spend cash to build assets that destroy debt.<br>
        3. <strong>Loans:</strong> Desperate? Take a loan, but the interest will drain you.<br><br>
        Protect your Net Worth from the Red Debt Blobs!</p>
        <button class="start-btn" onclick="startGame()">START DEFENSE</button>
    </div>

    <div id="game-over-screen" class="screen hidden">
        <h1 style="color:#f55">BANKRUPT</h1>
        <p>Your Net Worth hit zero.<br>Tip: Try to save more cash before the timer hits to maximize compound interest.</p>
        <button class="start-btn" onclick="startGame()">TRY AGAIN</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // --- CONFIG ---
    const TILE_SIZE = 60;
    const GRID_W = 16;
    const GRID_H = 10;
    const INTEREST_RATE = 0.05; // 5%
    const INTEREST_INTERVAL = 500; // Frames (approx 8.3 sec at 60fps) -> actually using Time
    
    // Map: 0=Grass(Build), 1=Path(Walk), 2=Base
    // Simple winding path
    const MAP_DATA = [
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [1,1,1,1,0,0,1,1,1,1,1,1,0,0,0,0],
        [0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0],
        [0,0,0,1,1,1,1,0,0,0,0,1,1,1,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],
        [0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0],
        [0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0],
        [0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0],
        [0,0,1,1,1,1,1,1,1,1,0,0,0,1,1,2],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ];

    // Convert map to waypoints
    const WAYPOINTS = [
        {c:0, r:1}, {c:3, r:1}, {c:3, r:3}, {c:6, r:3}, {c:6, r:1}, {c:11, r:1}, {c:11, r:3}, 
        {c:13, r:3}, {c:13, r:7}, {c:9, r:7}, {c:9, r:6}, {c:6, r:6}, {c:6, r:5}, {c:2, r:5},
        {c:2, r:8}, {c:9, r:8}, {c:9, r:6}, // Wait, map visual above doesn't perfectly match auto-pathing.
        // Hardcoding simplified path centers based on visual map above:
        {x:0.5, y:1.5}, {x:3.5, y:1.5}, {x:3.5, y:3.5}, {x:6.5, y:3.5}, {x:6.5, y:1.5}, 
        {x:11.5, y:1.5}, {x:11.5, y:3.5}, {x:13.5, y:3.5}, {x:13.5, y:8.5}, {x:15.5, y:8.5} // End
    ];
    // Correcting waypoints to match the array exactly
    const PATH_POINTS = [
        {c:0, r:1}, {c:3, r:1}, {c:3, r:3}, {c:6, r:3}, {c:6, r:1}, {c:11, r:1},
        {c:11, r:3}, {c:13, r:3}, {c:13, r:6}, {c:9, r:6}, {c:9, r:6}, // Simplified visual check
        // Actually, let's just make a simple function to follow '1's.
    ];
    
    // --- GAME STATE ---
    let state = {
        money: 400,
        lives: 20,
        wave: 1,
        debt: 0,
        lastInterestTime: 0,
        active: false,
        enemies: [],
        towers: [],
        projectiles: [],
        selectedTower: -1, // 0 or 1
        spawnTimer: 0,
        spawnCount: 0
    };

    function resize() {
        canvas.width = GRID_W * TILE_SIZE;
        canvas.height = GRID_H * TILE_SIZE;
    }
    resize();

    // --- LOGIC ---

    function startGame() {
        state = {
            money: 400,
            lives: 20,
            wave: 1,
            debt: 0,
            lastInterestTime: Date.now(),
            active: true,
            enemies: [],
            towers: [],
            projectiles: [],
            selectedTower: -1,
            spawnTimer: 0,
            spawnCount: 10
        };
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        updateUI();
        loop();
    }

    function update() {
        if (!state.active) return;
        const now = Date.now();

        // 1. INTEREST MECHANIC (Learning Point)
        let timeDiff = now - state.lastInterestTime;
        let timeLeft = Math.max(0, 5000 - timeDiff);
        document.getElementById('int-timer').innerText = (timeLeft / 1000).toFixed(1) + "s";
        
        if (timeDiff >= 5000) {
            // Apply Interest
            let interest = Math.floor(state.money * INTEREST_RATE);
            if (interest > 0) {
                state.money += interest;
                spawnFloatText(`+${interest} INTEREST`, canvas.width/2, canvas.height/2, '#00ff88');
            }
            state.lastInterestTime = now;
            
            // Apply Debt (Pain)
            if (state.debt > 0) {
                let debtPain = Math.ceil(state.debt * 0.10); // 10% debt interest
                state.money -= debtPain;
                spawnFloatText(`-${debtPain} DEBT PAY`, canvas.width/2, canvas.height/2 + 30, '#ff5555');
                if (state.money < 0) {
                    // Force sell towers? or just negative money?
                    // Negative money prevents building
                }
            }
        }

        // 2. SPAWNING
        if (state.spawnCount > 0) {
            state.spawnTimer++;
            if (state.spawnTimer > 60 - (state.wave * 2)) {
                spawnEnemy();
                state.spawnTimer = 0;
                state.spawnCount--;
            }
        } else if (state.enemies.length === 0) {
            // Wave Complete
            state.wave++;
            state.spawnCount = 5 + (state.wave * 3);
            spawnFloatText(`WAVE ${state.wave}`, canvas.width/2, 100, '#fff');
        }

        // 3. MOVING ENEMIES
        for (let i = state.enemies.length - 1; i >= 0; i--) {
            let e = state.enemies[i];
            moveEnemy(e);
            if (e.finished) {
                state.lives--;
                state.enemies.splice(i, 1);
            } else if (e.hp <= 0) {
                state.money += e.reward;
                state.enemies.splice(i, 1);
            }
        }

        // 4. TOWERS
        state.towers.forEach(t => {
            if (t.cooldown > 0) t.cooldown--;
            else {
                // Find target
                let target = getTarget(t);
                if (target) {
                    shoot(t, target);
                    t.cooldown = t.maxCooldown;
                }
            }
        });

        // 5. PROJECTILES
        for (let i = state.projectiles.length - 1; i >= 0; i--) {
            let p = state.projectiles[i];
            moveProjectile(p);
            if (p.hit) {
                p.target.hp -= p.dmg;
                state.projectiles.splice(i, 1);
            } else if (p.life <= 0) {
                state.projectiles.splice(i, 1);
            }
        }

        if (state.lives <= 0) gameOver();
        updateUI();
    }

    // --- GAMEPLAY HELPERS ---

    function spawnEnemy() {
        // Path following logic: Start at [1,0]
        state.enemies.push({
            x: 0, y: TILE_SIZE * 1.5,
            hp: 20 + (state.wave * 10),
            speed: 1 + (state.wave * 0.1),
            reward: 5,
            pathIndex: 0,
            finished: false,
            maxHp: 20 + (state.wave * 10)
        });
    }

    // Hardcoded path based on the map array visually
    // 0,1 -> 3,1 -> 3,3 -> 6,3 -> 6,1 -> 11,1 -> 11,3 -> 13,3 -> 13,6 -> 9,6 -> 9,8 -> 15,8
    const PATH_COORDS = [
        {x: 3.5, y: 1.5}, {x: 3.5, y: 3.5}, {x: 6.5, y: 3.5}, {x: 6.5, y: 1.5},
        {x: 11.5, y: 1.5}, {x: 11.5, y: 3.5}, {x: 13.5, y: 3.5}, {x: 13.5, y: 6.5},
        {x: 9.5, y: 6.5}, {x: 9.5, y: 8.5}, {x: 15.5, y: 8.5}
    ];

    function moveEnemy(e) {
        if (e.pathIndex >= PATH_COORDS.length) {
            e.finished = true;
            return;
        }
        let target = PATH_COORDS[e.pathIndex];
        let tx = target.x * TILE_SIZE;
        let ty = target.y * TILE_SIZE;
        
        let dx = tx - e.x;
        let dy = ty - e.y;
        let dist = Math.hypot(dx, dy);

        if (dist < e.speed) {
            e.x = tx;
            e.y = ty;
            e.pathIndex++;
        } else {
            e.x += (dx / dist) * e.speed;
            e.y += (dy / dist) * e.speed;
        }
    }

    function getTarget(tower) {
        // Simple: Closest
        let best = null;
        let minD = tower.range;
        state.enemies.forEach(e => {
            let d = Math.hypot(e.x - tower.x, e.y - tower.y);
            if (d < minD) {
                minD = d;
                best = e;
            }
        });
        return best;
    }

    function shoot(tower, target) {
        state.projectiles.push({
            x: tower.x, y: tower.y,
            target: target,
            speed: 10,
            dmg: tower.dmg,
            color: tower.type === 0 ? '#00ff88' : '#00ccff',
            life: 50,
            hit: false
        });
    }

    function moveProjectile(p) {
        // Homing missile
        if (!state.enemies.includes(p.target)) {
            p.life = 0; return;
        }
        let dx = p.target.x - p.x;
        let dy = p.target.y - p.y;
        let dist = Math.hypot(dx, dy);
        
        if (dist < p.speed) {
            p.hit = true;
        } else {
            p.x += (dx / dist) * p.speed;
            p.y += (dy / dist) * p.speed;
        }
    }

    // --- INTERACTION ---

    function selectTower(id) {
        state.selectedTower = id;
        document.getElementById('btn-t0').classList.remove('selected');
        document.getElementById('btn-t1').classList.remove('selected');
        document.getElementById(`btn-t${id}`).classList.add('selected');
    }

    function takeLoan() {
        state.money += 500;
        state.debt += 500;
        spawnFloatText("LOAN +500", canvas.width/2, canvas.height/2, '#fff');
    }

    function payDebt() {
        if (state.money >= 100 && state.debt > 0) {
            state.money -= 100;
            state.debt = Math.max(0, state.debt - 100);
        }
    }

    canvas.addEventListener('mousedown', e => {
        if (!state.active || state.selectedTower === -1) return;
        
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        const col = Math.floor(x / TILE_SIZE);
        const row = Math.floor(y / TILE_SIZE);

        if (col < 0 || col >= GRID_W || row < 0 || row >= GRID_H) return;

        // Check placement
        if (MAP_DATA[row][col] === 0) {
            // Check existing tower
            let occupied = state.towers.some(t => Math.floor(t.x/TILE_SIZE) === col && Math.floor(t.y/TILE_SIZE) === row);
            if (occupied) return;

            // Check cost
            let cost = state.selectedTower === 0 ? 100 : 300;
            if (state.money >= cost) {
                state.money -= cost;
                // Build
                state.towers.push({
                    x: (col + 0.5) * TILE_SIZE,
                    y: (row + 0.5) * TILE_SIZE,
                    type: state.selectedTower,
                    range: state.selectedTower === 0 ? 150 : 250,
                    dmg: state.selectedTower === 0 ? 5 : 20,
                    maxCooldown: state.selectedTower === 0 ? 20 : 60,
                    cooldown: 0
                });
                // Deselect
                state.selectedTower = -1;
                document.getElementById('btn-t0').classList.remove('selected');
                document.getElementById('btn-t1').classList.remove('selected');
            } else {
                spawnFloatText("NO CASH!", x, y, '#f55');
            }
        }
    });

    // --- DRAWING ---

    function draw() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Grid
        for(let r=0; r<GRID_H; r++) {
            for(let c=0; c<GRID_W; c++) {
                let val = MAP_DATA[r][c];
                let x = c * TILE_SIZE;
                let y = r * TILE_SIZE;
                
                if (val === 0) { // Grass
                    ctx.fillStyle = '#111';
                    ctx.fillRect(x, y, TILE_SIZE-1, TILE_SIZE-1);
                    // Draw build marker if available
                    if ((c+r)%2==0) { ctx.fillStyle='#161616'; ctx.fillRect(x,y,TILE_SIZE,TILE_SIZE); }
                } else if (val === 1) { // Path
                    ctx.fillStyle = '#222';
                    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                    ctx.strokeStyle = '#333';
                    ctx.strokeRect(x,y,TILE_SIZE,TILE_SIZE);
                } else if (val === 2) { // Base
                    ctx.fillStyle = '#0055aa';
                    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                }
            }
        }

        // Draw Towers
        state.towers.forEach(t => {
            ctx.fillStyle = t.type === 0 ? '#00ff88' : '#00ccff';
            ctx.beginPath();
            ctx.arc(t.x, t.y, 20, 0, Math.PI*2);
            ctx.fill();
            // Range (hover effect simplified)
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.beginPath();
            ctx.arc(t.x, t.y, t.range, 0, Math.PI*2);
            ctx.stroke();
        });

        // Draw Enemies
        state.enemies.forEach(e => {
            ctx.fillStyle = '#ff3333';
            ctx.beginPath();
            ctx.arc(e.x, e.y, 15, 0, Math.PI*2);
            ctx.fill();
            
            // Health Bar
            let hpPct = e.hp / e.maxHp;
            ctx.fillStyle = 'red';
            ctx.fillRect(e.x - 15, e.y - 25, 30, 5);
            ctx.fillStyle = '#0f0';
            ctx.fillRect(e.x - 15, e.y - 25, 30 * hpPct, 5);
        });

        // Draw Projectiles
        state.projectiles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 5, 0, Math.PI*2);
            ctx.fill();
        });
    }

    function spawnFloatText(txt, x, y, col) {
        let el = document.createElement('div');
        el.className = 'floater';
        el.innerText = txt;
        el.style.left = x + 'px';
        el.style.top = y + 'px';
        el.style.color = col;
        document.body.appendChild(el);
        setTimeout(()=>el.remove(), 1000);
    }

    function updateUI() {
        document.getElementById('money-val').innerText = "$" + Math.floor(state.money);
        document.getElementById('lives-val').innerText = state.lives;
        document.getElementById('wave-val').innerText = state.wave;
        document.getElementById('debt-val').innerText = "$" + state.debt;
        
        if (state.debt > 0) document.getElementById('debt-val').style.color = '#f00';
        else document.getElementById('debt-val').style.color = '#888';
    }

    function gameOver() {
        state.active = false;
        document.getElementById('game-over-screen').classList.remove('hidden');
    }

    function loop() {
        if (!state.active) return;
        update();
        draw();
        requestAnimationFrame(loop);
    }

</script>
</body>
</html>