<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEON BLUEPRINT: Master Engineer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&display=swap');

        :root {
            --bg: #050508;
            --panel: #0a0a12;
            --cyan: #00f3ff;
            --pink: #bc13fe;
            --yellow: #f1ff00;
            --green: #00ff66;
        }

        body {
            margin: 0;
            background: var(--bg);
            color: white;
            font-family: 'Rajdhani', sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            user-select: none;
        }

        /* --- HUD --- */
        #hud-bar {
            display: flex;
            justify-content: space-between;
            padding: 10px 30px;
            background: rgba(0,0,0,0.8);
            border-bottom: 1px solid #333;
            font-size: 1.5rem;
            z-index: 20;
        }

        .hud-item span { color: var(--cyan); font-weight: bold; }
        .hud-item.high span { color: var(--yellow); }

        #timer-container {
            position: absolute;
            top: 50px; left: 0; width: 100%; height: 6px;
            background: #222;
        }
        #timer-bar {
            height: 100%;
            background: var(--pink);
            width: 100%;
            transition: width 0.1s linear;
            box-shadow: 0 0 10px var(--pink);
        }

        /* --- BLUEPRINTS (TOP) --- */
        #blueprint-panel {
            height: 220px;
            background: var(--panel);
            border-bottom: 2px solid var(--cyan);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            padding-top: 10px;
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.15);
        }

        .view-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            transition: transform 0.3s;
        }

        .view-label {
            color: #fff; /* Made brighter white */
            font-size: 1.1rem;
            letter-spacing: 2px;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(255,255,255,0.5);
        }
        
        .blueprint-canvas {
            border: 2px solid rgba(0, 243, 255, 0.5); /* Thicker border */
            background: rgba(0, 10, 20, 1.0); /* Solid dark background for contrast */
            image-rendering: pixelated;
            border-radius: 4px;
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.2);
        }

        /* --- HOLOGRAM DECK (BOTTOM) --- */
        #hologram-deck {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            perspective: 1200px;
            background: radial-gradient(circle at center, #111 0%, #000 100%);
        }

        .holo-container {
            width: 220px;
            height: 280px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(255,255,255,0.02);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 8px;
            position: relative;
        }

        .holo-container:hover {
            border-color: var(--cyan);
            background: rgba(0, 243, 255, 0.05);
            transform: translateY(-10px) scale(1.02);
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
        }

        .holo-canvas { width: 100%; height: 85%; }
        .holo-label { font-size: 1.2rem; color: #555; font-weight: bold; margin-bottom: 10px; }
        .holo-container:hover .holo-label { color: var(--cyan); }

        /* --- OVERLAYS --- */
        #feedback {
            position: absolute;
            top: 55%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            opacity: 0;
            z-index: 50;
        }
        #feedback h2 { font-size: 4rem; margin: 0; text-shadow: 0 0 20px black; }
        #feedback .stars { font-size: 3rem; color: var(--yellow); }

        .screen {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 8, 0.98);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .hidden { display: none !important; }

        h1 { font-size: 5rem; color: var(--cyan); margin: 0; text-shadow: 0 0 30px var(--cyan); letter-spacing: 5px; }
        h2 { font-size: 2.5rem; color: white; margin: 10px 0; }
        p { color: #aaa; font-size: 1.2rem; max-width: 600px; text-align: center; line-height: 1.6; }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 30px 0;
            text-align: center;
        }
        .stat-box {
            background: rgba(255,255,255,0.05);
            padding: 15px 30px;
            border-radius: 8px;
            border: 1px solid #333;
        }
        .stat-val { font-size: 2.5rem; font-weight: bold; color: white; }
        .stat-lbl { color: var(--pink); font-size: 1rem; letter-spacing: 1px; }

        button.btn-neon {
            background: transparent;
            color: var(--cyan);
            border: 2px solid var(--cyan);
            padding: 15px 60px;
            font-size: 1.8rem;
            font-family: 'Rajdhani';
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
            transition: 0.2s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        button.btn-neon:hover {
            background: var(--cyan);
            color: #000;
            box-shadow: 0 0 40px var(--cyan);
        }

    </style>
</head>
<body>

    <div id="hud-bar">
        <div class="hud-item">LEVEL: <span id="ui-level">1</span></div>
        <div class="hud-item">SCORE: <span id="ui-score">0</span></div>
        <div class="hud-item high">BEST: <span id="ui-high">0</span></div>
    </div>
    
    <div id="timer-container"><div id="timer-bar"></div></div>

    <div id="blueprint-panel">
        <div class="view-card">
            <canvas id="cvs-plan" width="80" height="80" class="blueprint-canvas"></canvas>
            <div class="view-label">PLAN (TOP)</div>
        </div>
        <div class="view-card">
            <canvas id="cvs-left" width="80" height="80" class="blueprint-canvas"></canvas>
            <div class="view-label">LEFT</div>
        </div>
        <div class="view-card">
            <canvas id="cvs-front" width="80" height="80" class="blueprint-canvas"></canvas>
            <div class="view-label">FRONT</div>
        </div>
        <div class="view-card">
            <canvas id="cvs-right" width="80" height="80" class="blueprint-canvas"></canvas>
            <div class="view-label">RIGHT</div>
        </div>
    </div>

    <div id="hologram-deck">
        </div>

    <div id="feedback">
        <h2 id="fb-text">MATCH!</h2>
        <div id="fb-stars" class="stars">★★★</div>
    </div>

    <div id="start-screen" class="screen">
        <h1>NEON BLUEPRINT</h1>
        <p>REVERSE ENGINEERING PROTOCOL</p>
        <br>
        <p>1. Analyze the <strong>4 Blueprints</strong> (Top, Front, Left, Right).<br>
        2. Identify the matching rotating <strong>3D Hologram</strong> below.<br>
        3. Solve fast to earn <strong>Stars</strong> and maintain the link.</p>
        <button class="btn-neon" onclick="startGame()">INITIALIZE</button>
    </div>

    <div id="game-over-screen" class="screen hidden">
        <h1 style="color:var(--pink)">CONNECTION LOST</h1>
        <div class="stats-grid">
            <div class="stat-box">
                <div class="stat-val" id="end-score">0</div>
                <div class="stat-lbl">FINAL SCORE</div>
            </div>
            <div class="stat-box">
                <div class="stat-val" id="end-level">1</div>
                <div class="stat-lbl">SECTORS CLEARED</div>
            </div>
            <div class="stat-box">
                <div class="stat-val" id="end-stars">0</div>
                <div class="stat-lbl">TOTAL STARS</div>
            </div>
            <div class="stat-box">
                <div class="stat-val" id="end-high" style="color:var(--yellow)">0</div>
                <div class="stat-lbl">HIGH SCORE</div>
            </div>
        </div>
        <button class="btn-neon" onclick="startGame()">REBOOT SYSTEM</button>
    </div>

    <script>
        // --- AUDIO SYSTEM ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playTone(type) {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            
            const now = audioCtx.currentTime;
            if(type === 'win') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            } else {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.linearRampToValueAtTime(50, now + 0.4);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.4);
                osc.start(now); osc.stop(now + 0.4);
            }
        }

        // --- GAME STATE ---
        const GRID_SIZE = 3; 
        let state = {
            score: 0,
            highScore: localStorage.getItem('neon_high') || 0,
            level: 1,
            totalStars: 0,
            timeLeft: 100,
            correctIndex: 0,
            options: [],
            isRunning: false
        };

        let rotAngle = 0;
        let animationId = null; // FIXED: Initialize as null

        // --- CORE FUNCTIONS ---

        function startGame() {
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            
            state.score = 0;
            state.level = 1;
            state.totalStars = 0;
            state.highScore = localStorage.getItem('neon_high') || 0;
            state.isRunning = true;
            
            updateUI();
            nextLevel();
            
            // FIXED: Only start loop if not already running
            if(!animationId) loop();
        }

        function nextLevel() {
            // Difficulty curve: Time gets shorter
            let difficultyMod = Math.min(20, state.level * 2);
            state.timeLeft = 100; 
            
            // 1. Generate Logic
            let correctGrid = generateObject();
            let opts = [correctGrid];
            for(let i=0; i<3; i++) opts.push(mutateObject(correctGrid));

            // Shuffle
            state.correctIndex = Math.floor(Math.random() * 4);
            [opts[0], opts[state.correctIndex]] = [opts[state.correctIndex], opts[0]];
            state.options = opts;

            // 2. Render Blueprints
            drawBlueprint('cvs-plan', getProjection(correctGrid, 'PLAN'));
            drawBlueprint('cvs-front', getProjection(correctGrid, 'FRONT'));
            drawBlueprint('cvs-left', getProjection(correctGrid, 'LEFT'));
            drawBlueprint('cvs-right', getProjection(correctGrid, 'RIGHT'));

            // 3. Render 3D Choices
            const deck = document.getElementById('hologram-deck');
            deck.innerHTML = '';
            
            state.options.forEach((opt, idx) => {
                let div = document.createElement('div');
                div.className = 'holo-container';
                div.onclick = () => checkAnswer(idx);
                
                let cvs = document.createElement('canvas');
                cvs.className = 'holo-canvas';
                cvs.width = 200; cvs.height = 200;
                cvs.id = 'holo-' + idx;
                
                let lbl = document.createElement('div');
                lbl.className = 'holo-label';
                lbl.innerText = "OBJECT " + ["A","B","C","D"][idx];

                div.appendChild(cvs);
                div.appendChild(lbl);
                deck.appendChild(div);
            });

            updateUI();
        }

        function loop() {
            if(!state.isRunning) return;

            // Timer Logic
            let decay = 0.2 + (state.level * 0.03); 
            state.timeLeft -= decay;
            
            const bar = document.getElementById('timer-bar');
            bar.style.width = Math.max(0, state.timeLeft) + "%";
            
            if(state.timeLeft > 50) bar.style.backgroundColor = "#00f3ff";
            else if(state.timeLeft > 20) bar.style.backgroundColor = "#f1ff00";
            else bar.style.backgroundColor = "#bc13fe";

            if(state.timeLeft <= 0) {
                gameOver();
                return;
            }

            // 3D Rotation
            rotAngle += 0.02;
            state.options.forEach((grid, idx) => {
                let cvs = document.getElementById('holo-'+idx);
                if(cvs) drawHologram(cvs, grid, rotAngle);
            });

            animationId = requestAnimationFrame(loop);
        }

        function checkAnswer(idx) {
            if(!state.isRunning) return;

            if(idx === state.correctIndex) {
                // Correct
                playTone('win');
                
                let stars = 1;
                if(state.timeLeft > 70) stars = 3;
                else if(state.timeLeft > 40) stars = 2;
                
                state.totalStars += stars;
                state.score += (stars * 100) + (state.level * 50);
                state.level++;

                showFeedback(stars === 3 ? "PERFECT!" : "MATCH!", stars);
                
                nextLevel();
            } else {
                // Wrong
                playTone('lose');
                state.timeLeft -= 25; 
                showFeedback("ERROR", 0);
                
                document.body.style.transform = "translateX(10px)";
                setTimeout(() => document.body.style.transform = "none", 50);
            }
        }

        function gameOver() {
            state.isRunning = false;
            
            // FIXED: Properly stop the loop so restart works
            cancelAnimationFrame(animationId);
            animationId = null; 
            
            playTone('lose');

            if(state.score > state.highScore) {
                state.highScore = state.score;
                localStorage.setItem('neon_high', state.highScore);
            }

            document.getElementById('end-score').innerText = state.score;
            document.getElementById('end-level').innerText = state.level - 1;
            document.getElementById('end-stars').innerText = state.totalStars;
            document.getElementById('end-high').innerText = state.highScore;
            
            document.getElementById('game-over-screen').classList.remove('hidden');
        }

        function showFeedback(text, stars) {
            const el = document.getElementById('feedback');
            const txt = document.getElementById('fb-text');
            const str = document.getElementById('fb-stars');
            
            txt.innerText = text;
            txt.style.color = stars > 0 ? "#00f3ff" : "#bc13fe";
            
            let starStr = "";
            for(let i=0; i<stars; i++) starStr += "★";
            str.innerText = starStr;

            el.style.opacity = 1;
            el.style.transform = "translate(-50%, -50%) scale(1.2)";
            
            setTimeout(() => {
                el.style.opacity = 0;
                el.style.transform = "translate(-50%, -50%) scale(1)";
            }, 800);
        }

        function updateUI() {
            document.getElementById('ui-score').innerText = state.score;
            document.getElementById('ui-level').innerText = state.level;
            document.getElementById('ui-high').innerText = state.highScore;
        }

        // --- GEOMETRY GENERATION ---

        function createEmptyGrid() {
            let g = [];
            for(let x=0; x<GRID_SIZE; x++) {
                g[x] = [];
                for(let y=0; y<GRID_SIZE; y++) {
                    g[x][y] = [];
                    for(let z=0; z<GRID_SIZE; z++) g[x][y][z] = 0;
                }
            }
            return g;
        }

        function generateObject() {
            let grid = createEmptyGrid();
            grid[1][0][1] = 1; 
            
            let count = 5 + Math.floor(state.level / 2);
            count = Math.min(count, 12); 

            for(let i=0; i<count; i++) {
                let added = false;
                let attempts = 0;
                while(!added && attempts < 50) {
                    let rx = Math.floor(Math.random()*GRID_SIZE);
                    let ry = Math.floor(Math.random()*GRID_SIZE);
                    let rz = Math.floor(Math.random()*GRID_SIZE);
                    
                    if(grid[rx][ry][rz] === 0) {
                        if (hasNeighbor(grid, rx, ry, rz)) {
                            grid[rx][ry][rz] = 1;
                            added = true;
                        }
                    }
                    attempts++;
                }
            }
            return grid;
        }

        function mutateObject(original) {
            let grid = JSON.parse(JSON.stringify(original));
            let modified = false;
            let attempts = 0;
            
            while(!modified && attempts < 50) {
                let rx = Math.floor(Math.random()*GRID_SIZE);
                let ry = Math.floor(Math.random()*GRID_SIZE);
                let rz = Math.floor(Math.random()*GRID_SIZE);
                
                if (grid[rx][ry][rz] === 1) {
                    grid[rx][ry][rz] = 0; 
                    modified = true;
                } else {
                    if(hasNeighbor(grid, rx, ry, rz)) {
                        grid[rx][ry][rz] = 1; 
                        modified = true;
                    }
                }
                attempts++;
            }
            return grid;
        }

        function hasNeighbor(g, x, y, z) {
            if(x>0 && g[x-1][y][z]) return true;
            if(x<GRID_SIZE-1 && g[x+1][y][z]) return true;
            if(y>0 && g[x][y-1][z]) return true;
            if(y<GRID_SIZE-1 && g[x][y+1][z]) return true;
            if(z>0 && g[x][y][z-1]) return true;
            if(z<GRID_SIZE-1 && g[x][y][z+1]) return true;
            return false;
        }

        // --- PROJECTIONS ---
        function getProjection(grid, type) {
            let p2d = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));

            for(let y=0; y<GRID_SIZE; y++) {
                for(let x=0; x<GRID_SIZE; x++) {
                    for(let z=0; z<GRID_SIZE; z++) {
                        if(grid[x][y][z]) {
                            let row = GRID_SIZE - 1 - y; 
                            if(type === 'PLAN') {
                                p2d[z][x] = 1;
                            } else if(type === 'FRONT') {
                                p2d[row][x] = 1;
                            } else if(type === 'RIGHT') {
                                p2d[row][z] = 1;
                            } else if(type === 'LEFT') {
                                p2d[row][GRID_SIZE - 1 - z] = 1;
                            }
                        }
                    }
                }
            }
            return p2d;
        }

        // --- RENDERERS ---

        function drawBlueprint(id, p2d) {
            const cvs = document.getElementById(id);
            const ctx = cvs.getContext('2d');
            ctx.clearRect(0,0,80,80);
            
            let size = 80 / GRID_SIZE;
            
            // FIXED: Using actual color strings, not CSS vars
            ctx.strokeStyle = "rgba(0,243,255,0.2)";
            ctx.beginPath();
            for(let i=0; i<=GRID_SIZE; i++) {
                ctx.moveTo(i*size, 0); ctx.lineTo(i*size, 80);
                ctx.moveTo(0, i*size); ctx.lineTo(80, i*size);
            }
            ctx.stroke();

            // FIXED: Bright Cyan Fill
            ctx.fillStyle = "#00f3ff"; 
            for(let r=0; r<GRID_SIZE; r++) {
                for(let c=0; c<GRID_SIZE; c++) {
                    if(p2d[r][c]) {
                        ctx.fillRect(c*size+2, r*size+2, size-4, size-4);
                    }
                }
            }
        }

        function drawHologram(cvs, grid, angle) {
            const ctx = cvs.getContext('2d');
            ctx.clearRect(0,0,cvs.width,cvs.height);
            
            const cx = cvs.width/2;
            const cy = cvs.height/2;
            const scale = 35;

            let voxels = [];
            
            for(let x=0; x<GRID_SIZE; x++) {
                for(let y=0; y<GRID_SIZE; y++) {
                    for(let z=0; z<GRID_SIZE; z++) {
                        if(grid[x][y][z]) {
                            let ox = x - 1; 
                            let oy = y - 1; 
                            let oz = z - 1;

                            let rx = ox*Math.cos(angle) - oz*Math.sin(angle);
                            let rz = ox*Math.sin(angle) + oz*Math.cos(angle);
                            
                            voxels.push({x:rx, y:oy, z:rz, dist: rz});
                        }
                    }
                }
            }

            voxels.sort((a,b) => b.dist - a.dist);

            voxels.forEach(v => {
                drawCube(ctx, cx + v.x*scale, cy - v.y*scale, v.z, scale);
            });
        }

        function drawCube(ctx, x, y, z, s) {
            let depth = 1 + (z * 0.15); 
            let size = (s/2) * depth;
            
            ctx.lineWidth = 2;
            ctx.lineJoin = 'round';
            let off = size * 0.6; 
            
            ctx.fillStyle = `rgba(0, 243, 255, ${0.15 + (z+1)*0.05})`;
            ctx.beginPath();
            ctx.moveTo(x-size, y-size); 
            ctx.lineTo(x+size, y-size);
            ctx.lineTo(x+size, y+size);
            ctx.lineTo(x-size, y+size);
            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle = `rgba(0, 243, 255, ${0.4 + z*0.2})`;
            
            ctx.strokeRect(x-size, y-size, size*2, size*2);
            
            ctx.beginPath();
            ctx.moveTo(x-size, y-size); ctx.lineTo(x-size+off, y-size-off);
            ctx.moveTo(x+size, y-size); ctx.lineTo(x+size+off, y-size-off);
            ctx.moveTo(x-size, y+size); ctx.lineTo(x-size+off, y+size-off);
            ctx.moveTo(x+size, y+size); ctx.lineTo(x+size+off, y+size-off);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(x-size+off, y-size-off);
            ctx.lineTo(x+size+off, y-size-off);
            ctx.lineTo(x+size+off, y+size-off);
            ctx.stroke();
        }

    </script>
</body>
</html>
