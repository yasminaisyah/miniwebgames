<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEON BLUEPRINT: Reverse Engineer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&display=swap');

        :root {
            --bg: #020205;
            --grid: #111;
            --cyan: #0ff;
            --pink: #f0f;
            --yellow: #ff0;
            --glass: rgba(0, 255, 255, 0.05);
        }

        body {
            margin: 0;
            background: var(--bg);
            color: white;
            font-family: 'Rajdhani', sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            user-select: none;
        }

        /* --- TOP SECTION: THE CLUES (2D VIEWS) --- */
        #blueprint-panel {
            height: 220px;
            background: rgba(0,0,0,0.5);
            border-bottom: 2px solid var(--cyan);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 40px;
            position: relative;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.1);
        }

        .view-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .view-label {
            color: var(--cyan);
            font-size: 1.2rem;
            letter-spacing: 2px;
            text-shadow: 0 0 5px var(--cyan);
        }

        .blueprint-canvas {
            border: 1px solid rgba(0, 255, 255, 0.3);
            background: rgba(0, 20, 40, 0.6);
            image-rendering: pixelated;
        }

        /* --- BOTTOM SECTION: THE OPTIONS (3D) --- */
        #hologram-deck {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 20px;
            perspective: 1000px;
        }

        .holo-container {
            width: 200px;
            height: 250px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: radial-gradient(circle, rgba(0,255,255,0.05) 0%, transparent 70%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .holo-container:hover {
            border-color: var(--cyan);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.2) inset;
            transform: scale(1.05);
        }

        .holo-canvas {
            width: 100%;
            height: 80%;
        }

        .holo-label {
            font-size: 1.5rem;
            color: #555;
            font-weight: bold;
        }

        .holo-container:hover .holo-label { color: var(--cyan); }

        /* --- UI OVERLAYS --- */
        #hud {
            position: absolute;
            top: 10px; left: 20px;
            font-size: 1.5rem;
            color: white;
            z-index: 10;
        }

        #timer-bar {
            position: absolute;
            top: 0; left: 0; height: 4px;
            background: var(--pink);
            width: 100%;
            transition: width 0.1s linear;
        }

        #overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        h1 { font-size: 4rem; color: var(--cyan); margin: 0; text-shadow: 0 0 20px var(--cyan); }
        p { color: #aaa; font-size: 1.2rem; max-width: 600px; text-align: center; }
        
        button.btn-start {
            background: transparent;
            color: var(--cyan);
            border: 2px solid var(--cyan);
            padding: 15px 50px;
            font-size: 2rem;
            font-family: 'Rajdhani';
            cursor: pointer;
            margin-top: 30px;
            transition: 0.2s;
        }
        button.btn-start:hover { background: var(--cyan); color: #000; box-shadow: 0 0 30px var(--cyan); }
        
        .hidden { display: none !important; }

        #feedback {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 5rem;
            font-weight: bold;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 50;
            text-shadow: 0 0 20px black;
        }
    </style>
</head>
<body>

    <div id="timer-bar"></div>

    <div id="hud">
        SCORE: <span id="score">0</span> | LEVEL: <span id="level">1</span>
    </div>

    <div id="blueprint-panel">
        <div class="view-card">
            <canvas id="cvs-plan" width="100" height="100" class="blueprint-canvas"></canvas>
            <div class="view-label">PLAN</div>
        </div>
        <div class="view-card">
            <canvas id="cvs-front" width="100" height="100" class="blueprint-canvas"></canvas>
            <div class="view-label">FRONT</div>
        </div>
        <div class="view-card">
            <canvas id="cvs-side" width="100" height="100" class="blueprint-canvas"></canvas>
            <div class="view-label">SIDE</div>
        </div>
    </div>

    <div id="hologram-deck">
        </div>

    <div id="feedback">MATCH!</div>

    <div id="overlay">
        <h1>NEON BLUEPRINT</h1>
        <p>Reverse Engineering Protocol</p>
        <p>Analyze the 3 blue plans at the top.<br>Find the single rotating hologram that matches all of them.</p>
        <button class="btn-start" onclick="initGame()">INITIATE</button>
    </div>

    <script>
        // --- AUDIO ENGINE ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSfx(type) {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            
            const now = audioCtx.currentTime;
            
            if(type === 'correct') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            } else if (type === 'wrong') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.linearRampToValueAtTime(50, now + 0.3);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            }
        }

        // --- GAME ENGINE ---
        const GRID_SIZE = 3; 
        const CANVAS_SIZE = 100;
        
        let state = {
            score: 0,
            level: 1,
            timeLeft: 100,
            correctIndex: 0,
            options: [], // Array of 3D Grids
            isOver: false
        };

        let rotAngle = 0;
        let animationId;

        function initGame() {
            document.getElementById('overlay').classList.add('hidden');
            state.score = 0;
            state.level = 1;
            state.timeLeft = 100;
            state.isOver = false;
            nextLevel();
            loop();
        }

        function nextLevel() {
            // 1. Generate Correct 3D Object
            let correctGrid = generateObject();
            
            // 2. Generate 3 Decoys
            let opts = [correctGrid];
            for(let i=0; i<3; i++) {
                opts.push(mutateObject(correctGrid));
            }

            // 3. Shuffle
            state.correctIndex = Math.floor(Math.random() * 4);
            // Swap correct to random pos
            let temp = opts[0];
            opts[0] = opts[state.correctIndex];
            opts[state.correctIndex] = temp;
            
            state.options = opts;

            // 4. Draw The Blueprints (Top)
            drawBlueprint('cvs-plan', getProjection(correctGrid, 'PLAN'));
            drawBlueprint('cvs-front', getProjection(correctGrid, 'FRONT'));
            drawBlueprint('cvs-side', getProjection(correctGrid, 'SIDE'));

            // 5. Setup 3D Canvases
            const deck = document.getElementById('hologram-deck');
            deck.innerHTML = '';
            
            state.options.forEach((opt, idx) => {
                let div = document.createElement('div');
                div.className = 'holo-container';
                div.onclick = () => checkAnswer(idx);
                
                let cvs = document.createElement('canvas');
                cvs.className = 'holo-canvas';
                cvs.width = 200;
                cvs.height = 200;
                cvs.id = 'holo-' + idx;
                
                let lbl = document.createElement('div');
                lbl.className = 'holo-label';
                lbl.innerText = "OBJ-" + (idx+1);

                div.appendChild(cvs);
                div.appendChild(lbl);
                deck.appendChild(div);
            });
            
            // Difficulty Timer Reset
            state.timeLeft = 100;
            updateUI();
        }

        function loop() {
            if(state.isOver) return;

            // Update Time
            state.timeLeft -= 0.15 + (state.level * 0.02);
            document.getElementById('timer-bar').style.width = state.timeLeft + "%";
            
            if(state.timeLeft <= 0) gameOver();

            // Rotate Holograms
            rotAngle += 0.02;

            // Render all 3D Options
            state.options.forEach((grid, idx) => {
                let cvs = document.getElementById('holo-'+idx);
                if(cvs) drawHologram(cvs, grid, rotAngle);
            });

            animationId = requestAnimationFrame(loop);
        }

        function checkAnswer(idx) {
            if(state.isOver) return;

            if(idx === state.correctIndex) {
                // Win
                playSfx('correct');
                state.score += Math.floor(state.timeLeft * 10);
                state.level++;
                showFeedback("MATCH!", "#0ff");
                nextLevel();
            } else {
                // Lose
                playSfx('wrong');
                state.timeLeft -= 20;
                showFeedback("ERROR", "#f0f");
                // Shake effect
                document.body.style.transform = "translateX(10px)";
                setTimeout(() => document.body.style.transform = "none", 50);
            }
        }

        function gameOver() {
            state.isOver = true;
            cancelAnimationFrame(animationId);
            document.querySelector('#overlay h1').innerText = "SYSTEM FAILURE";
            document.querySelector('#overlay p').innerHTML = "Final Score: " + state.score;
            document.querySelector('#overlay button').innerText = "REBOOT";
            document.getElementById('overlay').classList.remove('hidden');
        }

        function showFeedback(txt, col) {
            const f = document.getElementById('feedback');
            f.innerText = txt;
            f.style.color = col;
            f.style.opacity = 1;
            setTimeout(() => f.style.opacity = 0, 500);
        }

        function updateUI() {
            document.getElementById('score').innerText = state.score;
            document.getElementById('level').innerText = state.level;
        }

        // --- LOGIC: GENERATION ---

        function generateObject() {
            let grid = createEmptyGrid();
            // Start at bottom center
            let x=1, y=0, z=1;
            grid[x][y][z] = 1;
            
            // Add blocks randomly attached to existing ones
            let blocks = 5 + Math.min(5, state.level); // More blocks as levels go up
            
            for(let i=0; i<blocks; i++) {
                // Simple approach: pick a random spot, if it has a neighbor, fill it
                let added = false;
                let attempts = 0;
                while(!added && attempts < 50) {
                    let rx = Math.floor(Math.random()*GRID_SIZE);
                    let ry = Math.floor(Math.random()*GRID_SIZE);
                    let rz = Math.floor(Math.random()*GRID_SIZE);
                    
                    if(grid[rx][ry][rz] === 0) {
                        if (hasNeighbor(grid, rx, ry, rz)) {
                            grid[rx][ry][rz] = 1;
                            added = true;
                        }
                    }
                    attempts++;
                }
            }
            return grid;
        }

        function mutateObject(original) {
            // Deep copy
            let grid = JSON.parse(JSON.stringify(original));
            let type = Math.random();
            
            // Modification: Add block or Remove block
            let modified = false;
            let attempts = 0;
            
            while(!modified && attempts < 50) {
                let rx = Math.floor(Math.random()*GRID_SIZE);
                let ry = Math.floor(Math.random()*GRID_SIZE);
                let rz = Math.floor(Math.random()*GRID_SIZE);
                
                if (grid[rx][ry][rz] === 1) {
                    // Try removing (but check connectivity? Nah, floating blocks allow simpler check)
                    // Just removing makes it clearly different
                    grid[rx][ry][rz] = 0;
                    modified = true;
                } else {
                    // Try adding
                    if(hasNeighbor(grid, rx, ry, rz)) {
                        grid[rx][ry][rz] = 1;
                        modified = true;
                    }
                }
                attempts++;
            }
            return grid;
        }

        function createEmptyGrid() {
            let g = [];
            for(let x=0; x<GRID_SIZE; x++) {
                g[x] = [];
                for(let y=0; y<GRID_SIZE; y++) {
                    g[x][y] = [];
                    for(let z=0; z<GRID_SIZE; z++) g[x][y][z] = 0;
                }
            }
            return g;
        }

        function hasNeighbor(g, x, y, z) {
            // Check 6 directions
            if(x>0 && g[x-1][y][z]) return true;
            if(x<GRID_SIZE-1 && g[x+1][y][z]) return true;
            if(y>0 && g[x][y-1][z]) return true;
            if(y<GRID_SIZE-1 && g[x][y+1][z]) return true;
            if(z>0 && g[x][y][z-1]) return true;
            if(z<GRID_SIZE-1 && g[x][y][z+1]) return true;
            return false;
        }

        // --- LOGIC: PROJECTION ---
        function getProjection(grid, type) {
            let p2d = [];
            for(let i=0; i<GRID_SIZE; i++) {
                p2d[i] = [];
                for(let j=0; j<GRID_SIZE; j++) p2d[i][j] = 0;
            }

            if(type === 'PLAN') {
                // Top View: Map X, Z.
                for(let x=0; x<GRID_SIZE; x++) {
                    for(let z=0; z<GRID_SIZE; z++) {
                        for(let y=0; y<GRID_SIZE; y++) {
                            if(grid[x][y][z]) p2d[z][x] = 1; // Z maps to Row, X maps to Col
                        }
                    }
                }
            }
            else if(type === 'FRONT') {
                // Front View: Look from Z+. See X, Y.
                for(let x=0; x<GRID_SIZE; x++) {
                    for(let y=0; y<GRID_SIZE; y++) {
                        for(let z=0; z<GRID_SIZE; z++) {
                            if(grid[x][y][z]) p2d[GRID_SIZE-1-y][x] = 1; // Invert Y for canvas coords
                        }
                    }
                }
            }
            else if(type === 'SIDE') {
                // Side View: Look from X+. See Z, Y.
                for(let z=0; z<GRID_SIZE; z++) {
                    for(let y=0; y<GRID_SIZE; y++) {
                        for(let x=0; x<GRID_SIZE; x++) {
                            if(grid[x][y][z]) p2d[GRID_SIZE-1-y][z] = 1;
                        }
                    }
                }
            }
            return p2d;
        }

        // --- DRAWING ---
        function drawBlueprint(id, grid) {
            const cvs = document.getElementById(id);
            const ctx = cvs.getContext('2d');
            ctx.clearRect(0,0,100,100);
            
            let size = 100 / GRID_SIZE;
            
            // Grid Lines
            ctx.strokeStyle = "rgba(0,255,255,0.2)";
            ctx.beginPath();
            for(let i=0; i<=GRID_SIZE; i++) {
                ctx.moveTo(i*size, 0); ctx.lineTo(i*size, 100);
                ctx.moveTo(0, i*size); ctx.lineTo(100, i*size);
            }
            ctx.stroke();

            // Blocks
            ctx.fillStyle = "#0ff";
            for(let r=0; r<GRID_SIZE; r++) {
                for(let c=0; c<GRID_SIZE; c++) {
                    if(grid[r][c]) {
                        ctx.fillRect(c*size + 2, r*size + 2, size - 4, size - 4);
                    }
                }
            }
        }

        function drawHologram(cvs, grid, angle) {
            const ctx = cvs.getContext('2d');
            ctx.clearRect(0,0,cvs.width,cvs.height);
            
            const cx = cvs.width/2;
            const cy = cvs.height/2;
            const scale = 40;

            // Sort voxels by depth to handle simple painter's algo
            // Rotate the camera around the Y axis
            // Rot Matrix around Y: 
            // x' = x*cos - z*sin
            // z' = x*sin + z*cos
            
            let voxels = [];
            
            for(let x=0; x<GRID_SIZE; x++) {
                for(let y=0; y<GRID_SIZE; y++) {
                    for(let z=0; z<GRID_SIZE; z++) {
                        if(grid[x][y][z]) {
                            // Center points around origin
                            let ox = x - 1; 
                            let oy = y - 1; 
                            let oz = z - 1;

                            let rx = ox*Math.cos(angle) - oz*Math.sin(angle);
                            let rz = ox*Math.sin(angle) + oz*Math.cos(angle);
                            
                            voxels.push({x:rx, y:oy, z:rz});
                        }
                    }
                }
            }

            // Sort by Z (furthest first)
            voxels.sort((a,b) => b.z - a.z);

            // Draw cubes
            voxels.forEach(v => {
                drawCube(ctx, cx + v.x*scale, cy - v.y*scale, v.z, scale);
            });
        }

        function drawCube(ctx, x, y, z, s) {
            // Isometric-ish projection of a single cube based on rotated coords
            // Since we already rotated X/Z, we just need to project 3D to 2D
            // Simple perspective: scale depends on Z
            let depth = 1 + (z * 0.1); 
            let size = (s/2) * depth;
            
            // Since we rotated the points, x and y are screen-ish coords relative to center
            // but we need to draw the cube faces. 
            // Wireframe style is safest for holograms.
            
            ctx.strokeStyle = `rgba(0, 255, 255, ${0.5 + z*0.2})`;
            ctx.lineWidth = 2;
            
            // Front Face
            ctx.strokeRect(x-size, y-size, size*2, size*2);
            
            // Back Face (fake perspective offset)
            let off = size * 0.5; 
            ctx.strokeRect(x-size+off, y-size-off, size*2, size*2);
            
            // Connecting lines
            ctx.beginPath();
            ctx.moveTo(x-size, y-size); ctx.lineTo(x-size+off, y-size-off);
            ctx.moveTo(x+size, y-size); ctx.lineTo(x+size+off, y-size-off);
            ctx.moveTo(x-size, y+size); ctx.lineTo(x-size+off, y+size-off);
            ctx.moveTo(x+size, y+size); ctx.lineTo(x+size+off, y+size-off);
            ctx.stroke();
            
            // Fill
            ctx.fillStyle = `rgba(0, 255, 255, 0.1)`;
            ctx.fillRect(x-size, y-size, size*2, size*2);
        }

    </script>
</body>
</html>