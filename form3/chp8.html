<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Locus Hunter V3: Infinite Generator</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;700&display=swap');

        :root {
            --bg-color: #0f0f1a;
            --accent-purple: #b957ce;
            --accent-cyan: #00f3ff;
            --correct-green: #00ff6a;
            --wrong-red: #ff2a2a;
            --glass: rgba(20, 20, 35, 0.9);
            --text-main: #ffffff;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: 'Roboto', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            user-select: none;
        }

        /* UI LAYOUT */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
        }

        .hud-panel {
            background: var(--glass);
            border-left: 4px solid var(--accent-cyan);
            padding: 25px;
            border-radius: 0 15px 15px 0;
            pointer-events: auto;
            max-width: 650px;
            box-shadow: 0 5px 30px rgba(0,0,0,0.6);
            backdrop-filter: blur(5px);
            margin-top: 20px;
            transition: opacity 0.3s;
        }

        h2 { 
            margin: 0 0 10px 0; 
            color: var(--accent-purple); 
            font-family: 'Orbitron', sans-serif; 
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(185, 87, 206, 0.4);
        }
        
        #question-text { 
            font-size: 1.4rem; 
            line-height: 1.4; 
            font-weight: bold;
        }

        #sub-text {
            font-size: 0.9rem;
            color: #aaa;
            margin-top: 5px;
            font-style: italic;
        }
        
        /* OVERLAYS (Start, End, Explanation) */
        .overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(10, 10, 20, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50;
            flex-direction: column;
            pointer-events: auto;
        }

        .hidden { display: none !important; }

        #explanation-box {
            background: #1a1a2e;
            border: 2px solid var(--correct-green);
            padding: 40px;
            text-align: center;
            border-radius: 20px;
            max-width: 500px;
            box-shadow: 0 0 60px rgba(0, 255, 106, 0.2);
            position: relative;
        }
        
        #explanation-title { 
            font-family: 'Orbitron'; 
            font-size: 2rem; 
            margin-bottom: 15px; 
        }
        
        #explanation-text { 
            font-size: 1.2rem; 
            margin-bottom: 30px; 
            line-height: 1.6;
        }
        
        .action-btn {
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-purple));
            color: #fff;
            border: none;
            padding: 15px 40px;
            font-weight: bold;
            font-size: 1.5rem;
            cursor: pointer;
            border-radius: 50px;
            font-family: 'Orbitron';
            transition: transform 0.2s;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.4);
            margin-top: 20px;
        }
        .action-btn:hover { transform: scale(1.05); }

        canvas {
            position: absolute;
            top: 0; left: 0;
            z-index: 1;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
        }

        /* Status Bar */
        #status-bar {
            position: absolute;
            top: 20px;
            right: 20px;
            font-family: 'Orbitron';
            font-size: 1.2rem;
            color: #fff;
            text-align: right;
            z-index: 15;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 10px;
            border: 1px solid #333;
        }

        /* End Game Styles */
        h1 { font-family: 'Orbitron'; font-size: 4rem; margin-bottom: 10px; color: var(--accent-cyan); text-shadow: 0 0 30px var(--accent-cyan); }
        .star-container { font-size: 4rem; margin: 20px 0; display: flex; gap: 10px; }
        .star { color: #333; text-shadow: 0 0 5px #000; transition: color 0.5s, text-shadow 0.5s; }
        .star.active { color: #ffd700; text-shadow: 0 0 30px #ffd700; animation: popIn 0.5s ease-out; }
        
        @keyframes popIn { 0% { transform: scale(0); } 80% { transform: scale(1.2); } 100% { transform: scale(1); } }

        .stat-row { font-size: 1.5rem; margin: 10px 0; color: #ccc; }
        .stat-val { color: #fff; font-weight: bold; }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="status-bar">
        TIME: <span id="time-display" style="color:var(--correct-green)">60</span>s<br>
        LEVEL: <span id="level-count" style="color:var(--accent-cyan)">1</span><br>
        SCORE: <span id="score-count" style="color:var(--accent-purple)">0</span>
    </div>

    <div id="ui-layer">
        <div class="hud-panel" id="hud-box">
            <h2>LOCUS MISSION</h2>
            <div id="question-text">Initializing Generator...</div>
            <div id="sub-text">Read the mission and click the correct geometric path.</div>
        </div>
    </div>

    <div id="start-screen" class="overlay">
        <h1>LOCUS HUNTER</h1>
        <p style="max-width: 600px; text-align: center; font-size: 1.2rem; margin-bottom: 30px; line-height: 1.5;">
            Identify the correct geometric path based on the description.<br>
            You have 60 seconds to solve as many missions as possible.
        </p>
        <div class="stat-row" style="font-size: 1rem;">TOP SCORE: <span id="menu-high-score">0</span></div>
        <button class="action-btn" onclick="startGame()">INITIATE SYSTEM</button>
    </div>

    <div id="explanation-overlay" class="overlay hidden" style="background: rgba(0,0,0,0.8);">
        <div id="explanation-box">
            <div id="explanation-title">SUCCESS</div>
            <div id="explanation-text">Explanation goes here.</div>
            <button class="action-btn" onclick="nextLevel()">NEXT MISSION >></button>
        </div>
    </div>

    <div id="game-over-screen" class="overlay hidden">
        <h1>MISSION COMPLETE</h1>
        <div class="star-container">
            <div class="star" id="star1">★</div>
            <div class="star" id="star2">★</div>
            <div class="star" id="star3">★</div>
        </div>
        <div class="stat-row">FINAL SCORE: <span class="stat-val" id="final-score">0</span></div>
        <div class="stat-row">HIGH SCORE: <span class="stat-val" id="final-high-score">0</span></div>
        <button class="action-btn" onclick="startGame()">REBOOT</button>
    </div>

<script>
/** * AUDIO SYSTEM 
 */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(type) {
    if(audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    
    const now = audioCtx.currentTime;
    
    if(type === 'win') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(523.25, now); // C
        osc.frequency.setValueAtTime(659.25, now + 0.1); // E
        osc.frequency.setValueAtTime(783.99, now + 0.2); // G
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
        osc.start(now);
        osc.stop(now + 0.4);
    } else if(type === 'lose') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.linearRampToValueAtTime(50, now + 0.4);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.linearRampToValueAtTime(0.001, now + 0.4);
        osc.start(now);
        osc.stop(now + 0.4);
    } else if(type === 'gameover') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 1);
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.linearRampToValueAtTime(0.001, now + 1);
        osc.start(now);
        osc.stop(now + 1);
    }
}

/**
 * INFINITE TEXT GENERATOR
 */
const VOCAB = {
    actors: ["A robot", "A drone", "A hungry goat", "A satellite", "A ninja", "A ship", "A secure signal"],
    actions: ["moves", "hovers", "patrols", "is located", "travels"],
    p1: ["Point A", "the Red Flag", "Base Alpha", "the Fire Station", "the center"],
    p2: ["Point B", "the Blue Flag", "Base Beta", "the Police Station", "the target"],
    line: ["the highway", "the straight wall", "the river bank", "the fence", "Line L"],
    line2: ["the railroad", "the old road", "Line M", "the boundary"],
    dist: ["5 meters", "10 steps", "3 km", "exactly 2 units", "a constant distance"]
};

function getRandom(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

function generateMissionText(type) {
    // 0: Circle, 1: Bisector, 2: Parallel, 3: Cross
    let text = "";
    const act = getRandom(VOCAB.actors);
    const verb = getRandom(VOCAB.actions);
    const d = getRandom(VOCAB.dist);
    
    if (type === 0) { // Fixed Point -> Circle
        const point = getRandom(VOCAB.p1);
        const templates = [
            `${act} ${verb} keeping ${d} from ${point}.`,
            `Find the locus of a point that is always ${d} away from ${point}.`,
            `${act} rotates around ${point} at a distance of ${d}.`
        ];
        text = getRandom(templates);
    } 
    else if (type === 1) { // 2 Points -> Bisector
        const a = getRandom(VOCAB.p1);
        const b = getRandom(VOCAB.p2);
        const templates = [
            `${act} ${verb} so it is equidistant from ${a} and ${b}.`,
            `Find the path that stays exactly in the middle of ${a} and ${b}.`,
            `A boundary line is drawn between ${a} and ${b}.`
        ];
        text = getRandom(templates);
    }
    else if (type === 2) { // Line -> Parallel
        const l = getRandom(VOCAB.line);
        const templates = [
            `${act} ${verb} maintaining ${d} from ${l}.`,
            `Find the locus of points at a constant distance of ${d} from ${l}.`,
            `${act} follows a path parallel to ${l}.`
        ];
        text = getRandom(templates);
    }
    else if (type === 3) { // Intersect -> Angle Bisector
        const l1 = getRandom(VOCAB.line);
        const l2 = getRandom(VOCAB.line2);
        const templates = [
            `${act} ${verb} equidistant from the intersection of ${l1} and ${l2}.`,
            `Find the locus of a point equidistant from two intersecting lines.`,
            `A path cuts exactly between the crossing of ${l1} and ${l2}.`
        ];
        text = getRandom(templates);
    }
    return text;
}

/**
 * GAME ENGINE
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const questionEl = document.getElementById('question-text');
const hudPanel = document.getElementById('hud-box');

// Screens
const startScreen = document.getElementById('start-screen');
const gameOverScreen = document.getElementById('game-over-screen');
const explOverlay = document.getElementById('explanation-overlay');
const explBox = document.getElementById('explanation-box');
const explTitle = document.getElementById('explanation-title');
const explText = document.getElementById('explanation-text');

let w, h;
let gameState = 'START'; // START, PLAYING, EXPLAINING, GAMEOVER
let currentLevel = null;
let options = [];
let mouseX = 0, mouseY = 0;
let levelCount = 1;
let score = 0;
let timer = 60;
let lastTime = 0;

// High Score Loading
let highScore = localStorage.getItem('locusHunterHS') || 0;
document.getElementById('menu-high-score').innerText = highScore;

function resize() {
    w = canvas.width = window.innerWidth;
    h = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

function startGame() {
    score = 0;
    levelCount = 1;
    timer = 60;
    lastTime = Date.now();
    gameState = 'PLAYING';
    
    startScreen.classList.add('hidden');
    gameOverScreen.classList.add('hidden');
    explOverlay.classList.add('hidden');
    hudPanel.style.opacity = "1";
    
    updateHUD();
    startLevel();
    loop();
}

function startLevel() {
    // Pick Random Type
    let newType = Math.floor(Math.random() * 4);
    if (currentLevel && currentLevel.type === newType) {
        newType = (newType + 1) % 4; // Prevent repeat
    }
    
    const text = generateMissionText(newType);
    
    currentLevel = {
        type: newType,
        text: text,
        cx: w/2,
        cy: h * 0.4
    };
    
    questionEl.innerText = text;
    updateHUD();

    // Generate Visual Options
    options = [];
    const correctId = newType; 
    const btnY = h * 0.75;
    const spacing = Math.min(300, w/3);
    const btnX = [w/2 - spacing, w/2, w/2 + spacing];
    
    // Mobile adjustment
    if(w < 800) {
        btnX[0] = w*0.2; btnX[1] = w*0.5; btnX[2] = w*0.8;
    }

    let icons = [0, 1, 2, 3];
    icons.splice(correctId, 1);
    icons.sort(() => Math.random() - 0.5);
    let choices = [correctId, icons[0], icons[1]];
    choices.sort(() => Math.random() - 0.5);

    choices.forEach((id, index) => {
        options.push({
            x: btnX[index],
            y: btnY,
            r: 50,
            iconId: id,
            isCorrect: (id === correctId)
        });
    });
}

function handleInput() {
    if(gameState !== 'PLAYING') return;

    options.forEach(opt => {
        const d = Math.hypot(mouseX - opt.x, mouseY - opt.y);
        if(d < opt.r) {
            // Check Answer
            if(opt.isCorrect) {
                score += 100;
                playSound('win');
                showExplanation(true);
            } else {
                score = Math.max(0, score - 50);
                timer = Math.max(0, timer - 5); // Penalty
                playSound('lose');
                showExplanation(false);
            }
        }
    });
}

function showExplanation(isWin) {
    gameState = 'EXPLAINING';
    explOverlay.classList.remove('hidden');
    
    if(isWin) {
        explTitle.innerText = "CORRECT ANALYSIS";
        explTitle.style.color = "var(--correct-green)";
        explBox.style.borderColor = "var(--correct-green)";
    } else {
        explTitle.innerText = "INCORRECT";
        explTitle.style.color = "var(--wrong-red)";
        explBox.style.borderColor = "var(--wrong-red)";
    }
    
    const explanations = [
        "A constant distance from a fixed point always creates a <b>CIRCLE</b>.",
        "Equidistant from two fixed points creates a <b>PERPENDICULAR BISECTOR</b> (a line down the middle).",
        "A constant distance from a straight line creates <b>PARALLEL LINES</b>.",
        "Equidistant from intersecting lines creates an <b>ANGLE BISECTOR</b> (The 'X' cut)."
    ];
    
    explText.innerHTML = explanations[currentLevel.type];
}

function nextLevel() {
    explOverlay.classList.add('hidden');
    levelCount++;
    gameState = 'PLAYING';
    lastTime = Date.now(); // Reset delta to prevent timer jump
    startLevel();
}

function updateHUD() {
    document.getElementById('level-count').innerText = levelCount;
    document.getElementById('score-count').innerText = score;
    document.getElementById('time-display').innerText = Math.ceil(timer);
    
    const timeEl = document.getElementById('time-display');
    if (timer < 10) timeEl.style.color = 'var(--wrong-red)';
    else timeEl.style.color = 'var(--correct-green)';
}

function endGame() {
    gameState = 'GAMEOVER';
    playSound('gameover');
    
    hudPanel.style.opacity = "0";
    gameOverScreen.classList.remove('hidden');
    
    // Calculate Stars
    let stars = 0;
    if (score > 300) stars = 1;
    if (score > 800) stars = 2;
    if (score > 1500) stars = 3;
    
    // Render Stars
    const s1 = document.getElementById('star1');
    const s2 = document.getElementById('star2');
    const s3 = document.getElementById('star3');
    s1.className = 'star'; s2.className = 'star'; s3.className = 'star';
    
    if (stars >= 1) setTimeout(() => s1.classList.add('active'), 200);
    if (stars >= 2) setTimeout(() => s2.classList.add('active'), 500);
    if (stars >= 3) setTimeout(() => s3.classList.add('active'), 800);
    
    // High Score Logic
    if (score > highScore) {
        highScore = score;
        localStorage.setItem('locusHunterHS', highScore);
    }
    
    document.getElementById('final-score').innerText = score;
    document.getElementById('final-high-score').innerText = highScore;
    document.getElementById('menu-high-score').innerText = highScore;
}

/**
 * RENDER & LOOP
 */
function drawIcon(ctx, id, x, y, scale=1) {
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 3 * scale;
    
    if(id === 0) { // Circle
        ctx.beginPath(); ctx.arc(x, y, 25*scale, 0, Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.arc(x, y, 3*scale, 0, Math.PI*2); ctx.fill();
    }
    else if(id === 1) { // Bisector
        ctx.fillStyle='#666';
        ctx.beginPath(); ctx.arc(x-20*scale, y, 4*scale, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(x+20*scale, y, 4*scale, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle='#fff';
        ctx.beginPath(); ctx.moveTo(x, y-25*scale); ctx.lineTo(x, y+25*scale); ctx.stroke();
    }
    else if(id === 2) { // Parallel
        ctx.beginPath();
        ctx.moveTo(x-20*scale, y-15*scale); ctx.lineTo(x+20*scale, y-15*scale);
        ctx.moveTo(x-20*scale, y+15*scale); ctx.lineTo(x+20*scale, y+15*scale);
        ctx.stroke();
    }
    else if(id === 3) { // Cross
        ctx.beginPath();
        ctx.moveTo(x-20*scale, y-20*scale); ctx.lineTo(x+20*scale, y+20*scale);
        ctx.moveTo(x+20*scale, y-20*scale); ctx.lineTo(x-20*scale, y+20*scale);
        ctx.stroke();
    }
}

function drawProblem(ctx) {
    if (!currentLevel) return;
    const cx = currentLevel.cx;
    const cy = currentLevel.cy;
    
    ctx.strokeStyle = '#fff';
    ctx.fillStyle = '#fff';
    ctx.lineWidth = 2;
    
    // Draw Scenario Visuals (Top center)
    if(currentLevel.type === 0) { // Point
        ctx.beginPath(); ctx.arc(cx, cy, 5, 0, Math.PI*2); ctx.fill();
        ctx.fillText("P", cx+10, cy-10);
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.beginPath(); ctx.arc(cx, cy, 80, 0, Math.PI*2); ctx.stroke();
    }
    else if(currentLevel.type === 1) { // 2 Points
        ctx.beginPath(); ctx.arc(cx-80, cy, 5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(cx+80, cy, 5, 0, Math.PI*2); ctx.fill();
    }
    else if(currentLevel.type === 2) { // Line
        ctx.beginPath(); ctx.moveTo(cx-100, cy); ctx.lineTo(cx+100, cy); ctx.stroke();
    }
    else if(currentLevel.type === 3) { // X
        ctx.beginPath(); 
        ctx.moveTo(cx-60, cy-60); ctx.lineTo(cx+60, cy+60); 
        ctx.moveTo(cx+60, cy-60); ctx.lineTo(cx-60, cy+60); 
        ctx.stroke();
    }

    // Explanation Mode: Show Answer in Green
    if(gameState === 'EXPLAINING') {
        const time = Date.now()/100;
        ctx.strokeStyle = '#00ff6a';
        ctx.lineWidth = 4;
        ctx.setLineDash([10, 10]);
        ctx.lineDashOffset = -time;
        
        if(currentLevel.type === 0) {
            ctx.beginPath(); ctx.arc(cx, cy, 80, 0, Math.PI*2); ctx.stroke();
        } else if(currentLevel.type === 1) {
            ctx.beginPath(); ctx.moveTo(cx, cy-100); ctx.lineTo(cx, cy+100); ctx.stroke();
        } else if(currentLevel.type === 2) {
            ctx.beginPath(); 
            ctx.moveTo(cx-100, cy-40); ctx.lineTo(cx+100, cy-40); 
            ctx.moveTo(cx-100, cy+40); ctx.lineTo(cx+100, cy+40); 
            ctx.stroke();
        } else if(currentLevel.type === 3) {
            ctx.beginPath(); ctx.moveTo(cx, cy-80); ctx.lineTo(cx, cy+80); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(cx-80, cy); ctx.lineTo(cx+80, cy); ctx.stroke();
        }
        ctx.setLineDash([]);
    }
}

function loop() {
    ctx.clearRect(0, 0, w, h);
    
    // Background Grid
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    ctx.lineWidth = 1;
    for(let i=0; i<w; i+=50) { ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,h); ctx.stroke(); }
    
    if(gameState === 'PLAYING') {
        // Timer Logic
        const now = Date.now();
        const dt = (now - lastTime) / 1000;
        lastTime = now;
        
        timer -= dt;
        if (timer <= 0) {
            timer = 0;
            updateHUD();
            endGame();
            return; // Stop rendering this frame
        }
        updateHUD();
        
        // Draw Options
        options.forEach(opt => {
            const d = Math.hypot(mouseX - opt.x, mouseY - opt.y);
            const isHover = (d < opt.r);
            
            ctx.beginPath();
            ctx.arc(opt.x, opt.y, opt.r, 0, Math.PI*2);
            ctx.fillStyle = isHover ? 'rgba(0, 243, 255, 0.3)' : 'rgba(0, 0, 0, 0.5)';
            ctx.fill();
            ctx.strokeStyle = isHover ? '#fff' : 'var(--accent-cyan)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            drawIcon(ctx, opt.iconId, opt.x, opt.y);
            
            if(isHover) {
                ctx.shadowColor = '#00f3ff';
                ctx.shadowBlur = 20;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
        });
    }
    
    if (gameState === 'PLAYING' || gameState === 'EXPLAINING') {
        drawProblem(ctx);
    }

    if (gameState !== 'GAMEOVER') {
        requestAnimationFrame(loop);
    }
}

canvas.addEventListener('mousemove', e => { mouseX=e.clientX; mouseY=e.clientY; });
canvas.addEventListener('click', handleInput);

</script>
</body>
</html>
