<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Brain Blitz - Survival Mode</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap');

        :root {
            --bg-grad: linear-gradient(120deg, #84fab0 0%, #8fd3f4 100%);
            --card-bg: #ffffff;
            --btn-blue: #3498db;
            --btn-blue-shadow: #2980b9;
            --btn-correct: #2ecc71;
            --btn-correct-shadow: #27ae60;
            --btn-wrong: #e74c3c;
            --btn-wrong-shadow: #c0392b;
            --text-color: #2c3e50;
        }

        body {
            margin: 0;
            font-family: 'Fredoka', sans-serif;
            background: var(--bg-grad);
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            user-select: none;
        }

        /* Animated Background Blobs */
        .blob {
            position: absolute;
            filter: blur(50px);
            z-index: 0;
            opacity: 0.5;
            animation: float 12s infinite ease-in-out;
        }
        .blob-1 { top: -10%; left: -10%; width: 300px; height: 300px; background: #ff9a9e; border-radius: 40% 60% 70% 30%; }
        .blob-2 { bottom: -10%; right: -10%; width: 400px; height: 400px; background: #a18cd1; border-radius: 60% 40% 30% 70%; animation-delay: -5s; }

        @keyframes float {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            50% { transform: translate(30px, 50px) rotate(20deg); }
        }

        /* Main Game Card */
        .game-card {
            background: var(--card-bg);
            width: 90%;
            max-width: 500px;
            padding: 25px;
            border-radius: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.2);
            text-align: center;
            position: relative;
            z-index: 10;
        }

        /* HUD: Lives and Score */
        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .lives-container {
            font-size: 1.5rem;
            letter-spacing: 5px;
        }

        .score-box {
            background: #34495e;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
        }

        /* Streak Badge */
        .streak-container {
            height: 25px;
            margin-bottom: 10px;
        }
        .streak-pill {
            display: inline-block;
            background: #f1c40f;
            color: #fff;
            padding: 4px 15px;
            border-radius: 20px;
            opacity: 0;
            transition: opacity 0.3s, transform 0.2s;
            font-weight: bold;
            font-size: 0.9rem;
            box-shadow: 0 4px 0 #d35400;
        }

        /* Question Area */
        .category-badge {
            display: inline-block;
            background: #9b59b6;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.75rem;
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        #question-text {
            font-size: 1.5rem;
            color: var(--text-color);
            margin-bottom: 25px;
            line-height: 1.3;
            min-height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Buttons */
        .options-grid {
            display: grid;
            gap: 12px;
        }

        .game-btn {
            background-color: var(--btn-blue);
            color: white;
            border: none;
            padding: 15px;
            font-size: 1.1rem;
            font-family: 'Fredoka', sans-serif;
            border-radius: 15px;
            cursor: pointer;
            position: relative;
            box-shadow: 0 5px 0 var(--btn-blue-shadow); 
            transition: transform 0.1s;
        }

        .game-btn:active {
            transform: translateY(5px);
            box-shadow: none;
        }

        .game-btn.correct { background-color: var(--btn-correct); box-shadow: 0 5px 0 var(--btn-correct-shadow); }
        .game-btn.wrong { background-color: var(--btn-wrong); box-shadow: 0 5px 0 var(--btn-wrong-shadow); opacity: 0.6; }

        /* Overlays (Start & Game Over) */
        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255,255,255,0.96);
            border-radius: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
        }

        .big-btn {
            background: #ff6b6b;
            color: white;
            font-size: 1.8rem;
            padding: 15px 50px;
            border-radius: 50px;
            border: none;
            cursor: pointer;
            box-shadow: 0 8px 0 #ee5253;
            font-family: 'Fredoka', sans-serif;
            transition: transform 0.1s;
            margin-top: 20px;
        }
        .big-btn:active { transform: translateY(8px); box-shadow: none; }

        h1 { margin: 0; color: #3498db; font-size: 2.8rem; }
        h2 { margin: 0; color: #e74c3c; font-size: 2.5rem; }
        p { color: #7f8c8d; margin: 10px 0 20px 0; }

        /* Animations */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        .shake { animation: shake 0.3s; }

        /* Confetti */
        .confetti {
            position: absolute;
            width: 10px; height: 10px;
            background-color: #f2d74e;
            z-index: 50;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div class="blob blob-1"></div>
    <div class="blob blob-2"></div>

    <div class="game-card" id="game-card">
        
        <div id="start-screen" class="overlay">
            <h1>Brain Blitz</h1>
            <p>5 Lives ‚Ä¢ Infinite Levels</p>
            <button class="big-btn" onclick="startGame()">PLAY</button>
            <div id="loading-msg" style="margin-top:15px; font-size:0.8rem; display:none;">Loading questions...</div>
        </div>

        <div id="game-over-screen" class="overlay" style="display:none;">
            <h2>Game Over!</h2>
            <p>You ran out of hearts.</p>
            <div style="font-size: 1.5rem; margin-bottom: 10px;">Score: <span id="final-score">0</span></div>
            <button class="big-btn" onclick="restartGame()">Try Again</button>
        </div>

        <div class="hud-top">
            <div class="lives-container" id="lives-display">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
            <div class="score-box">Score: <span id="score">0</span></div>
        </div>

        <div class="streak-container">
            <div class="streak-pill" id="streak-pill">üî• Streak: <span id="streak">0</span></div>
        </div>

        <div class="category-badge" id="category-badge">General</div>
        <div id="question-text">Question goes here...</div>

        <div class="options-grid" id="options-grid"></div>
    </div>

<script>
    // --- State ---
    const state = {
        queue: [],
        score: 0,
        streak: 0,
        lives: 5,
        token: null,
        isFetching: false,
        canAnswer: false
    };

    // --- Audio System ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playTone(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        const t = audioCtx.currentTime;

        if (type === 'correct') {
            osc.frequency.setValueAtTime(440, t); 
            osc.frequency.linearRampToValueAtTime(880, t + 0.1);
            gain.gain.setValueAtTime(0.1, t);
            gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
            osc.start(t); osc.stop(t + 0.3);
        } else if (type === 'wrong') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(150, t);
            osc.frequency.linearRampToValueAtTime(100, t + 0.3);
            gain.gain.setValueAtTime(0.1, t);
            gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
            osc.start(t); osc.stop(t + 0.3);
        } else if (type === 'gameover') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(300, t);
            osc.frequency.linearRampToValueAtTime(50, t + 1);
            gain.gain.setValueAtTime(0.2, t);
            gain.gain.linearRampToValueAtTime(0, t + 1);
            osc.start(t); osc.stop(t + 1);
        }
    }

    // --- Logic ---
    async function getToken() {
        try {
            let res = await fetch('https://opentdb.com/api_token.php?command=request');
            let data = await res.json();
            state.token = data.token;
        } catch(e) {}
    }

    async function fetchQuestions() {
        if(state.isFetching) return;
        state.isFetching = true;
        
        let url = `https://opentdb.com/api.php?amount=40&type=multiple`;
        if(state.token) url += `&token=${state.token}`;

        try {
            let res = await fetch(url);
            let data = await res.json();
            if(data.response_code === 0) {
                state.queue.push(...data.results);
            } else if (data.response_code === 4) {
                await getToken(); // Refresh token
                state.isFetching = false;
                fetchQuestions(); // Retry
                return;
            }
        } catch(e) {}
        state.isFetching = false;
        
        // If initial load
        if(document.getElementById('start-screen').style.display !== 'none' && state.queue.length > 0) {
            runGameLoop();
        }
    }

    async function startGame() {
        document.getElementById('loading-msg').style.display = 'block';
        await getToken();
        await fetchQuestions();
        runGameLoop();
    }

    function runGameLoop() {
        document.getElementById('start-screen').style.display = 'none';
        document.getElementById('game-over-screen').style.display = 'none';
        renderQuestion();
    }

    function restartGame() {
        state.score = 0;
        state.lives = 5;
        state.streak = 0;
        updateStats();
        document.getElementById('game-over-screen').style.display = 'none';
        // We likely still have questions in queue, so instant start
        if(state.queue.length === 0) fetchQuestions();
        else renderQuestion();
    }

    function renderQuestion() {
        if(state.queue.length < 5) fetchQuestions(); // Pre-fetch more

        if(state.queue.length === 0) {
            // Wait a moment if empty (network lag)
            setTimeout(renderQuestion, 500);
            return;
        }

        const q = state.queue.pop();
        
        // Parse Text
        const parser = new DOMParser();
        const parse = (str) => parser.parseFromString(`<!doctype html><body>${str}`, 'text/html').body.textContent;

        document.getElementById('category-badge').innerText = q.category.split(':')[0];
        document.getElementById('question-text').innerText = parse(q.question);

        // Answers
        let answers = [...q.incorrect_answers, q.correct_answer];
        answers.sort(() => Math.random() - 0.5);

        const grid = document.getElementById('options-grid');
        grid.innerHTML = '';

        answers.forEach(ans => {
            let btn = document.createElement('button');
            btn.className = 'game-btn';
            btn.innerText = parse(ans);
            btn.onclick = () => handleAnswer(btn, ans, q.correct_answer);
            grid.appendChild(btn);
        });

        state.canAnswer = true;
    }

    function handleAnswer(btn, selected, correct) {
        if(!state.canAnswer) return;
        state.canAnswer = false;

        const isCorrect = (selected === correct);

        if(isCorrect) {
            btn.classList.add('correct');
            playTone('correct');
            state.streak++;
            state.score += 10 + (state.streak * 2);
            spawnConfetti(btn);
            setTimeout(renderQuestion, 800);
        } else {
            btn.classList.add('wrong');
            playTone('wrong');
            
            // Highlight actual correct answer
            [...document.querySelectorAll('.game-btn')].forEach(b => {
                if(b.innerText === correct) b.classList.add('correct'); // Note: innerText is parsed
            });

            state.streak = 0;
            state.lives--;
            
            // Shake effect
            document.getElementById('game-card').classList.add('shake');
            setTimeout(() => document.getElementById('game-card').classList.remove('shake'), 300);

            if(state.lives <= 0) {
                setTimeout(triggerGameOver, 1000);
            } else {
                setTimeout(renderQuestion, 1500); // Longer delay to see correct answer
            }
        }
        updateStats();
    }

    function triggerGameOver() {
        playTone('gameover');
        document.getElementById('final-score').innerText = state.score;
        document.getElementById('game-over-screen').style.display = 'flex';
    }

    function updateStats() {
        document.getElementById('score').innerText = state.score;
        document.getElementById('streak').innerText = state.streak;
        
        // Render Hearts
        let hearts = "";
        for(let i=0; i<state.lives; i++) hearts += "‚ù§Ô∏è";
        for(let i=state.lives; i<5; i++) hearts += "üñ§"; // Empty hearts
        document.getElementById('lives-display').innerText = hearts;

        // Streak Visibility
        const pill = document.getElementById('streak-pill');
        pill.style.opacity = state.streak > 1 ? '1' : '0';
        pill.style.transform = state.streak > 1 ? 'scale(1.1)' : 'scale(1)';
        setTimeout(() => pill.style.transform = 'scale(1)', 200);
    }

    // --- Visuals ---
    function spawnConfetti(elem) {
        const rect = elem.getBoundingClientRect();
        for(let i=0; i<15; i++) {
            let c = document.createElement('div');
            c.className = 'confetti';
            c.style.left = (rect.left + rect.width/2) + 'px';
            c.style.top = rect.top + 'px';
            c.style.background = `hsl(${Math.random()*360}, 100%, 50%)`;
            document.body.appendChild(c);
            
            let x = (Math.random()-0.5)*200;
            let y = Math.random()*200 + 50;
            
            c.animate([
                { transform: 'translate(0,0)' },
                { transform: `translate(${x}px, ${y}px) rotate(${Math.random()*720}deg)`, opacity: 0 }
            ], { duration: 800 }).onfinish = () => c.remove();
        }
    }
</script>
</body>
</html>