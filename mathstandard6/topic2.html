<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Galactic Math Miner</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Exo+2:wght@400;700&family=Righteous&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #0b0e14;
            font-family: 'Exo 2', sans-serif;
            touch-action: none;
            user-select: none;
        }

        #game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
        }

        /* Top HUD */
        #hud-top {
            display: flex;
            justify-content: space-between;
            padding: 15px;
            background: rgba(0, 0, 0, 0.6);
            border-bottom: 2px solid #00d9ff;
        }

        .stat-box {
            color: #00d9ff;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 0 5px #00d9ff;
        }

        /* Question Display - Always Visible */
        #question-display {
            margin-top: 10px;
            align-self: center;
            background: rgba(16, 26, 46, 0.9);
            border: 2px solid #ffcc00;
            border-radius: 15px;
            padding: 15px 40px;
            text-align: center;
            box-shadow: 0 0 20px rgba(255, 204, 0, 0.3);
            pointer-events: auto; /* Allow clicking if needed, though mostly visual */
        }

        #q-label {
            display: block;
            color: #aaa;
            font-size: 14px;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        #q-text {
            color: white;
            font-family: 'Righteous', cursive;
            font-size: 32px;
            margin: 0;
            letter-spacing: 1px;
        }

        /* Controls Area (Bottom) */
        #controls-area {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            gap: 20px;
        }

        .control-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            backdrop-filter: blur(5px);
        }

        #fire-btn {
            width: 90px;
            height: 90px;
            background: rgba(255, 50, 50, 0.3);
            border: 2px solid #ff3333;
            font-weight: bold;
            font-size: 18px;
            box-shadow: 0 0 15px #ff3333;
        }

        /* Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            pointer-events: auto;
        }

        h1 {
            font-family: 'Righteous', cursive;
            font-size: 50px;
            background: linear-gradient(to right, #00d9ff, #ff00cc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 20px;
            text-align: center;
        }

        .btn-main {
            padding: 15px 40px;
            font-size: 24px;
            background: #00d9ff;
            color: #000;
            border: none;
            border-radius: 5px;
            font-family: 'Righteous', cursive;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(0, 217, 255, 0.5);
        }

        .hidden { display: none !important; }

    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="game-ui">
    <div id="hud-top">
        <div class="stat-box">SCORE: <span id="score">0</span></div>
        <div class="stat-box">LIVES: <span id="lives">3</span></div>
    </div>

    <div id="question-display">
        <span id="q-label">Current Mission</span>
        <h2 id="q-text">Loading...</h2>
    </div>

    <div id="controls-area">
        <div class="control-btn" id="btn-left">◀</div>
        <div class="control-btn" id="fire-btn">FIRE</div>
        <div class="control-btn" id="btn-right">▶</div>
    </div>
</div>

<div id="start-screen" class="screen">
    <h1>MATH MINER</h1>
    <p style="color:white; text-align:center; max-width:500px; margin-bottom:30px; font-size: 18px; line-height: 1.5;">
        Take your time. Read the question.<br>
        Move your ship to aim at the correct Ore.<br>
        Press <strong>FIRE</strong> to extract the answer.<br>
        (Keyboard: Left/Right Arrows + Spacebar)
    </p>
    <button class="btn-main" onclick="Game.start()">START MINING</button>
</div>

<div id="game-over-screen" class="screen hidden">
    <h1 style="color: #ff3333;">MISSION OVER</h1>
    <p style="color:white; font-size: 24px;">Score: <span id="final-score">0</span></p>
    <button class="btn-main" onclick="Game.start()">TRY AGAIN</button>
</div>

<script>
/* ================= AUDIO SYSTEM ================= */
const AudioSys = {
    ctx: null,
    init() {
        if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    },
    play(type) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const now = this.ctx.currentTime;
        
        osc.connect(gain);
        gain.connect(this.ctx.destination);

        if (type === 'move') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.linearRampToValueAtTime(100, now + 0.1);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.1);
            osc.start(now);
            osc.stop(now + 0.1);
        } else if (type === 'laser') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(800, now);
            osc.frequency.exponentialRampToValueAtTime(100, now + 0.3);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.3);
            osc.start(now);
            osc.stop(now + 0.3);
        } else if (type === 'explosion') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.exponentialRampToValueAtTime(10, now + 0.5);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.5);
            osc.start(now);
            osc.stop(now + 0.5);
        } else if (type === 'success') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(400, now);
            osc.frequency.linearRampToValueAtTime(800, now + 0.1);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.4);
            osc.start(now);
            osc.stop(now + 0.4);
        }
    }
};

/* ================= MATH ENGINE (Chapter 2) ================= */
const MathEngine = {
    getLevelMode(level) {
        const modes = [
            'percent_simple', 'decimal_op', 'fraction_of_million', 
            'fraction_div_whole', 'mixed_op'
        ];
        return modes[(level - 1) % modes.length];
    },
    generate(level) {
        let mode = this.getLevelMode(level);
        if(level > 5) mode = 'mixed_op'; // Randomize after level 5
        
        let q, a, w1, w2, w3;

        switch(mode) {
            case 'percent_simple':
                // e.g., 0.25 to %
                let v = [10, 20, 25, 50, 75, 5, 1][Math.floor(Math.random()*7)];
                q = `Convert ${v/100} to %`;
                a = `${v}%`;
                w1 = `${v/10}%`; w2 = `${v+10}%`; w3 = `${100-v}%`;
                break;
            case 'decimal_op':
                let d1 = (Math.random()*5).toFixed(1);
                let d2 = (Math.random()*5).toFixed(1);
                q = `${d1} + ${d2}`;
                a = (parseFloat(d1)+parseFloat(d2)).toFixed(1);
                w1 = (parseFloat(d1)+parseFloat(d2)+0.1).toFixed(1);
                w2 = (parseFloat(d1)*parseFloat(d2)).toFixed(1);
                w3 = (parseFloat(d1)).toFixed(1);
                break;
            case 'fraction_of_million':
                // Based on Table of Contents (Ch1/Ch2 overlap)
                q = "1/2 Million is?";
                a = "500,000";
                w1 = "50,000"; w2 = "250,000"; w3 = "5,000,000";
                // Randomize slightly
                if(Math.random()>0.5) { q="1/4 Million is?"; a="250,000"; w1="25,000"; w2="500,000"; w3="400,000"; }
                break;
            case 'fraction_div_whole':
                // 1/2 ÷ 2
                let den = [2,4,8][Math.floor(Math.random()*3)];
                let div = 2;
                q = `1/${den} ÷ ${div}`;
                a = `1/${den*div}`;
                w1 = `1/${den}`; w2 = `${div}/${den}`; w3 = `2/${den}`;
                break;
            default: // mixed_op
                // BODMAS: 2 + 3 x 4
                let m1 = Math.floor(Math.random()*5)+1;
                let m2 = Math.floor(Math.random()*5)+1;
                let m3 = Math.floor(Math.random()*3)+1;
                q = `${m1} + ${m2} × ${m3}`;
                a = m1 + (m2*m3);
                w1 = (m1+m2)*m3; // Wrong order
                w2 = a+1;
                w3 = a-1;
                break;
        }

        return { q, a, wrongs: [w1, w2, w3] };
    }
};

/* ================= GAME LOGIC ================= */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const Game = {
    state: 'start', // start, playing, gameover
    score: 0,
    lives: 3,
    level: 1,
    lastTime: 0,
    
    // Entities
    ship: { x: 0, width: 60, height: 40, speed: 300 }, // speed in px/sec
    laser: null, // {x, y, active}
    rocks: [], // {x, y, dx, dy, val, isCorrect, radius}
    particles: [],

    input: { left: false, right: false, fire: false },

    init() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.setupInput();
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    },

    resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        this.ship.y = 120; // Fixed distance from top
        if (this.state === 'start') this.ship.x = canvas.width / 2;
    },

    setupInput() {
        // Keyboard
        window.addEventListener('keydown', e => {
            if (e.key === 'ArrowLeft') this.input.left = true;
            if (e.key === 'ArrowRight') this.input.right = true;
            if (e.key === ' ' || e.key === 'Enter') this.triggerFire();
        });
        window.addEventListener('keyup', e => {
            if (e.key === 'ArrowLeft') this.input.left = false;
            if (e.key === 'ArrowRight') this.input.right = false;
        });

        // Touch UI
        const btnLeft = document.getElementById('btn-left');
        const btnRight = document.getElementById('btn-right');
        const btnFire = document.getElementById('fire-btn');

        const addTouch = (elem, key) => {
            elem.addEventListener('touchstart', (e) => { e.preventDefault(); this.input[key] = true; });
            elem.addEventListener('touchend', (e) => { e.preventDefault(); this.input[key] = false; });
            elem.addEventListener('mousedown', (e) => { e.preventDefault(); this.input[key] = true; });
            elem.addEventListener('mouseup', (e) => { e.preventDefault(); this.input[key] = false; });
        };

        addTouch(btnLeft, 'left');
        addTouch(btnRight, 'right');
        
        btnFire.addEventListener('touchstart', (e) => { e.preventDefault(); this.triggerFire(); });
        btnFire.addEventListener('mousedown', (e) => { e.preventDefault(); this.triggerFire(); });
    },

    triggerFire() {
        if (this.state === 'playing' && !this.laser) {
            AudioSys.play('laser');
            this.laser = {
                x: this.ship.x,
                y: this.ship.y + 40,
                speed: 800
            };
        }
    },

    start() {
        AudioSys.init();
        this.state = 'playing';
        this.score = 0;
        this.lives = 3;
        this.level = 1;
        this.rocks = [];
        this.laser = null;
        this.particles = [];
        this.ship.x = canvas.width / 2;
        
        this.updateHUD();
        this.spawnLevel();
        
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
    },

    spawnLevel() {
        const data = MathEngine.generate(this.level);
        document.getElementById('q-text').innerText = data.q;

        // Create Rocks
        this.rocks = [];
        let answers = [data.a, ...data.wrongs];
        // Shuffle
        answers.sort(() => Math.random() - 0.5);

        // Spawn positions (keep them in bottom half)
        const zoneY = canvas.height * 0.4;
        const availableHeight = canvas.height - zoneY - 100;
        
        answers.forEach((ans, i) => {
            let r = {
                x: Math.random() * (canvas.width - 100) + 50,
                y: zoneY + Math.random() * availableHeight,
                dx: (Math.random() - 0.5) * 60, // Very Slow movement (pixels per second)
                dy: (Math.random() - 0.5) * 40,
                radius: 45,
                val: ans,
                isCorrect: (ans === data.a),
                angle: Math.random() * Math.PI
            };
            this.rocks.push(r);
        });
    },

    update(dt) {
        if (this.state !== 'playing') return;

        // Ship Movement
        if (this.input.left) this.ship.x -= this.ship.speed * dt;
        if (this.input.right) this.ship.x += this.ship.speed * dt;
        
        // Clamp Ship
        if (this.ship.x < 40) this.ship.x = 40;
        if (this.ship.x > canvas.width - 40) this.ship.x = canvas.width - 40;

        // Laser Movement
        if (this.laser) {
            this.laser.y += this.laser.speed * dt;
            
            // Check collision with rocks
            for (let i = 0; i < this.rocks.length; i++) {
                let r = this.rocks[i];
                let dist = Math.hypot(this.laser.x - r.x, this.laser.y - r.y);
                
                if (dist < r.radius + 5) {
                    // HIT
                    this.laser = null;
                    this.createExplosion(r.x, r.y, r.isCorrect ? '#00ff00' : '#ff0000');
                    
                    if (r.isCorrect) {
                        AudioSys.play('success');
                        this.score += 100;
                        this.level++;
                        this.spawnLevel(); // Immediate next level
                    } else {
                        AudioSys.play('explosion');
                        this.lives--;
                        this.rocks.splice(i, 1); // Remove wrong rock
                        if (this.lives <= 0) this.gameOver();
                    }
                    this.updateHUD();
                    break;
                }
            }

            // Laser off screen
            if (this.laser && this.laser.y > canvas.height) {
                this.laser = null;
            }
        }

        // Rock Movement (Bouncing)
        this.rocks.forEach(r => {
            r.x += r.dx * dt;
            r.y += r.dy * dt;
            r.angle += dt;

            // Wall Bounce
            if (r.x < r.radius || r.x > canvas.width - r.radius) r.dx *= -1;
            // Floor/Ceiling (Invisible ceiling at 40% height)
            if (r.y < (canvas.height * 0.35) || r.y > canvas.height - r.radius - 80) r.dy *= -1;
        });

        // Particle Update
        this.particles.forEach((p, i) => {
            p.x += p.dx;
            p.y += p.dy;
            p.life -= dt;
            if(p.life <= 0) this.particles.splice(i, 1);
        });
    },

    createExplosion(x, y, color) {
        for(let i=0; i<15; i++) {
            this.particles.push({
                x: x, y: y,
                dx: (Math.random() - 0.5) * 10,
                dy: (Math.random() - 0.5) * 10,
                life: 0.5,
                color: color,
                size: Math.random() * 5 + 2
            });
        }
    },

    draw() {
        // Clear
        ctx.fillStyle = '#0b0e14';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw Stars (Static background detail)
        ctx.fillStyle = 'white';
        for(let i=0; i<50; i++) {
            ctx.fillRect( (i*137)%canvas.width, (i*233)%canvas.height, 1, 1);
        }

        if (this.state === 'playing') {
            // Draw Laser
            if (this.laser) {
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 4;
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#00ff00';
                ctx.beginPath();
                ctx.moveTo(this.laser.x, this.laser.y - 20);
                ctx.lineTo(this.laser.x, this.laser.y + 20);
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            // Draw Ship
            ctx.save();
            ctx.translate(this.ship.x, this.ship.y);
            // Hull
            ctx.fillStyle = '#00d9ff';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-30, -40);
            ctx.lineTo(30, -40);
            ctx.closePath();
            ctx.fill();
            // Engine
            ctx.fillStyle = '#555';
            ctx.fillRect(-15, -45, 10, 10);
            ctx.fillRect(5, -45, 10, 10);
            // Gun
            ctx.fillStyle = '#fff';
            ctx.fillRect(-5, 0, 10, 20);
            ctx.restore();

            // Draw Rocks
            this.rocks.forEach(r => {
                ctx.save();
                ctx.translate(r.x, r.y);
                ctx.rotate(r.angle);
                
                // Rock Body
                ctx.fillStyle = '#3a3a50';
                ctx.strokeStyle = '#6a6a80';
                ctx.lineWidth = 3;
                ctx.beginPath();
                // Rough octagon
                for(let i=0; i<8; i++) {
                    let a = (i/8) * Math.PI * 2;
                    let rad = r.radius + (Math.sin(i*3)*5);
                    ctx.lineTo(Math.cos(a)*rad, Math.sin(a)*rad);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Text
                ctx.rotate(-r.angle); // Counter rotate for text
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 20px "Exo 2"';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(r.val, 0, 0);

                ctx.restore();
            });

            // Particles
            this.particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life * 2;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1;
            });

            // Line from ship to bottom (Targeting aid)
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(this.ship.x, this.ship.y);
            ctx.lineTo(this.ship.x, canvas.height);
            ctx.stroke();
        }
    },

    updateHUD() {
        document.getElementById('score').innerText = this.score;
        document.getElementById('lives').innerText = this.lives;
    },

    gameOver() {
        this.state = 'gameover';
        document.getElementById('final-score').innerText = this.score;
        document.getElementById('game-over-screen').classList.remove('hidden');
    },

    loop(timestamp) {
        let dt = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;
        if (dt > 0.1) dt = 0.1; // Cap lag

        this.update(dt);
        this.draw();
        requestAnimationFrame(this.loop);
    }
};

Game.init();

</script>
</body>
</html>