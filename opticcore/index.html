<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optic Core: Laser Logic</title>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #05070a;
            --grid-line: #1f2937;
            --neon-cyan: #00f3ff;
            --neon-pink: #ff00ff;
            --neon-green: #00ff41;
            --glass: rgba(0, 243, 255, 0.1);
        }

        body {
            margin: 0;
            /* Changed from hidden to auto to allow scrolling */
            overflow: auto; 
            background-color: var(--bg-color);
            font-family: 'Share Tech Mono', monospace;
            color: var(--neon-cyan);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
            user-select: none;
        }

        /* Scanline Overlay */
        body::before {
            content: "";
            position: fixed; /* Fixed so it stays while scrolling */
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%);
            background-size: 100% 4px;
            z-index: 100;
            pointer-events: none;
            opacity: 0.3;
        }

        /* UI Header */
        header {
            width: 100%;
            max-width: 500px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--grid-line);
            padding-bottom: 10px;
            z-index: 10;
        }

        h1 {
            margin: 0;
            font-size: 1.8rem;
            text-shadow: 0 0 10px var(--neon-cyan);
            letter-spacing: 2px;
        }

        .level-badge {
            border: 1px solid var(--neon-green);
            padding: 5px 15px;
            color: var(--neon-green);
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.2);
            font-size: 1.2rem;
        }

        /* Main Game Area */
        .game-wrapper {
            position: relative;
            padding: 4px;
            background: linear-gradient(45deg, #333, #000);
            border-radius: 4px;
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.15);
            /* Ensure container fits on mobile */
            max-width: 100%;
        }

        canvas {
            background: #0a0d14;
            cursor: crosshair;
            display: block;
            border: 1px solid var(--grid-line);
            /* Responsive Scaling */
            max-width: 100%;
            height: auto;
        }

        /* Controls */
        .controls {
            margin-top: 25px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            z-index: 10;
            width: 100%;
            max-width: 500px;
        }

        button {
            background: rgba(0, 243, 255, 0.1);
            border: 1px solid var(--neon-cyan);
            color: var(--neon-cyan);
            padding: 12px 30px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
        }

        button:hover {
            background: var(--neon-cyan);
            color: #000;
            box-shadow: 0 0 20px var(--neon-cyan);
        }

        button:active {
            transform: scale(0.98);
        }

        button.secondary {
            border-color: #555;
            color: #888;
            background: transparent;
        }
        button.secondary:hover {
            border-color: #fff;
            color: #fff;
            box-shadow: none;
            background: rgba(255,255,255,0.1);
        }

        /* Instructions Overlay */
        .instructions {
            color: #888;
            font-size: 0.9rem;
            margin-top: 20px;
            text-align: center;
            line-height: 1.6;
            max-width: 500px;
        }

        /* Notifications */
        #message-overlay {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid var(--neon-green);
            padding: 20px;
            width: 80%;
            text-align: center;
            display: none;
            z-index: 20;
            box-shadow: 0 0 50px rgba(0, 255, 65, 0.3);
        }

        #message-overlay h2 {
            color: var(--neon-green);
            font-size: 2rem;
            margin: 0 0 10px 0;
        }

        #message-overlay p {
            color: white;
            font-size: 1.1rem;
        }

    </style>
</head>
<body>

    <header>
        <h1>OPTIC CORE</h1>
        <div class="level-badge">LEVEL <span id="level-display">1</span></div>
    </header>

    <div class="game-wrapper">
        <canvas id="gameCanvas" width="500" height="500"></canvas>
        
        <div id="message-overlay">
            <h2>SYSTEM SECURED</h2>
            <p>Laser connection established.</p>
        </div>
    </div>

    <div class="controls">
        <button onclick="fireLaser()">ACTIVATE LASER</button>
        <button class="secondary" onclick="resetLevel()">Clear Mirrors</button>
    </div>

    <div class="instructions">
        1. Find the <strong>GREEN</strong> dot (Start) and <strong>RED</strong> dot (Target).<br>
        2. Click empty squares to place <strong>Blue Mirrors</strong>.<br>
        3. Click mirrors to <strong>rotate</strong> them.<br>
        4. Press <strong>ACTIVATE</strong> to test your path!
    </div>

    <script>
        // --- Audio System ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx = new AudioContext();

        function playSound(type) {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const now = audioCtx.currentTime;

            if (type === 'place') {
                // Metallic click
                osc.type = 'square';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } 
            else if (type === 'fire') {
                // Laser rising hum
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.linearRampToValueAtTime(300, now + 0.2);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.linearRampToValueAtTime(0.1, now + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 1.5);
                osc.start(now);
                osc.stop(now + 1.5);
            }
            else if (type === 'reflect') {
                // High ping
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1200, now);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            }
            else if (type === 'success') {
                // Victory Chord
                const freqs = [440, 554, 659]; // A Major
                freqs.forEach((f, i) => {
                    const o = audioCtx.createOscillator();
                    const g = audioCtx.createGain();
                    o.type = 'triangle';
                    o.frequency.value = f;
                    g.gain.setValueAtTime(0.1, now);
                    g.gain.exponentialRampToValueAtTime(0.001, now + 1.0 + (i*0.2));
                    o.connect(g);
                    g.connect(audioCtx.destination);
                    o.start(now);
                    o.stop(now + 1.5);
                });
                return;
            }

            osc.connect(gain);
            gain.connect(audioCtx.destination);
        }

        // --- Game Constants & Variables ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const GRID_SIZE = 10; // 10x10 grid
        const CELL_SIZE = canvas.width / GRID_SIZE;

        let level = 1;
        let grid = []; // 0: Empty, 1: Block, 2: Mirror /, 3: Mirror \
        let source = { x: 0, y: 0, dir: 'right' };
        let target = { x: 9, y: 9 };
        let laserPath = [];
        let isFiring = false;

        // Directions: 0: up, 1: right, 2: down, 3: left
        const DIRS = [ {x:0, y:-1}, {x:1, y:0}, {x:0, y:1}, {x:-1, y:0} ];

        // --- Initialization ---
        
        function initGame() {
            generateLevel();
            draw();
            
            // Input Handling
            canvas.addEventListener('mousedown', handleInput);
            // Support Touch
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Prevent scroll when touching canvas
                // Use the first touch point
                const touch = e.touches[0];
                const fakeEvent = {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                };
                handleInput(fakeEvent);
            }, {passive: false});
        }

        function generateLevel() {
            grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
            laserPath = [];
            isFiring = false;
            document.getElementById('message-overlay').style.display = 'none';

            // 1. Pick random edge for Source
            const edge = Math.floor(Math.random() * 4);
            if(edge === 0) { source = {x: Math.floor(Math.random()*GRID_SIZE), y: 0, dir: 2}; } // Top
            else if(edge === 1) { source = {x: GRID_SIZE-1, y: Math.floor(Math.random()*GRID_SIZE), dir: 3}; } // Right
            else if(edge === 2) { source = {x: Math.floor(Math.random()*GRID_SIZE), y: GRID_SIZE-1, dir: 0}; } // Bottom
            else { source = {x: 0, y: Math.floor(Math.random()*GRID_SIZE), dir: 1}; } // Left

            // 2. Simulate a path to create a solvable level
            let cx = source.x;
            let cy = source.y;
            let cdir = source.dir;
            let steps = 0;
            
            // Force at least 3 turns for complexity
            const targetTurns = 3 + Math.floor(level / 2); 
            
            // Move cursor to generate path
            while(steps < 20) {
                // Move forward a random amount
                let dist = Math.floor(Math.random() * 4) + 2;
                
                for(let d=0; d<dist; d++) {
                    cx += DIRS[cdir].x;
                    cy += DIRS[cdir].y;
                    
                    // Check bounds
                    if(cx < 0 || cx >= GRID_SIZE || cy < 0 || cy >= GRID_SIZE) {
                        // Hit wall, step back and ensure this is the target
                        cx -= DIRS[cdir].x;
                        cy -= DIRS[cdir].y;
                        target = {x: cx, y: cy};
                        steps = 100; // Break outer
                        break;
                    }
                }
                
                if(steps === 100) break;

                // Turn
                // In the real game, a mirror would be needed here.
                // We leave it empty for the user to fill, but mark the spot as "not a wall"
                // Randomly turn left or right
                if(Math.random() > 0.5) {
                    // Turn Right (relative)
                    cdir = (cdir + 1) % 4;
                } else {
                    // Turn Left (relative)
                    cdir = (cdir + 3) % 4;
                }
            }

            // 3. Add random Obstacles (Walls)
            let walls = 4 + level;
            while(walls > 0) {
                let wx = Math.floor(Math.random() * GRID_SIZE);
                let wy = Math.floor(Math.random() * GRID_SIZE);
                // Don't block source/target
                if((wx !== source.x || wy !== source.y) && (wx !== target.x || wy !== target.y)) {
                    grid[wy][wx] = 1; // Wall
                    walls--;
                }
            }
        }

        function resetLevel() {
            // Clear only mirrors (2 and 3)
            for(let y=0; y<GRID_SIZE; y++) {
                for(let x=0; x<GRID_SIZE; x++) {
                    if(grid[y][x] >= 2) grid[y][x] = 0;
                }
            }
            laserPath = [];
            isFiring = false;
            draw();
        }

        function handleInput(e) {
            if(isFiring) return; // Lock during animation

            const rect = canvas.getBoundingClientRect();
            // Calculate scale in case canvas size differs from display size
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const x = Math.floor(((e.clientX - rect.left) * scaleX) / CELL_SIZE);
            const y = Math.floor(((e.clientY - rect.top) * scaleY) / CELL_SIZE);

            // Check Bounds
            if(x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return;

            // Logic
            if(x === source.x && y === source.y) return;
            if(x === target.x && y === target.y) return;
            if(grid[y][x] === 1) return; // Wall

            playSound('place');

            // Cycle: Empty -> Mirror / (2) -> Mirror \ (3) -> Empty (0)
            if(grid[y][x] === 0) grid[y][x] = 2;
            else if(grid[y][x] === 2) grid[y][x] = 3;
            else if(grid[y][x] === 3) grid[y][x] = 0;

            draw();
        }

        function fireLaser() {
            if(isFiring) return;
            isFiring = true;
            playSound('fire');
            laserPath = [];
            
            let cx = source.x;
            let cy = source.y;
            let cdir = source.dir;
            let active = true;
            let steps = 0;

            // Trace Loop
            const traceInterval = setInterval(() => {
                steps++;
                if(steps > 100) active = false; // Timeout

                // Move
                cx += DIRS[cdir].x;
                cy += DIRS[cdir].y;

                // Add to path
                laserPath.push({x: cx, y: cy});
                draw(); // Redraw with new beam segment

                // Collision Checks
                
                // 1. Out of bounds
                if(cx < 0 || cx >= GRID_SIZE || cy < 0 || cy >= GRID_SIZE) {
                    active = false;
                }
                // 2. Hit Wall
                else if(grid[cy][cx] === 1) {
                    active = false;
                }
                // 3. Hit Target
                else if(cx === target.x && cy === target.y) {
                    active = false;
                    winLevel();
                }
                // 4. Hit Mirror
                else if(grid[cy][cx] === 2) { // Mirror /
                    playSound('reflect');
                    // If hitting from Right (dir 3), go Up (dir 0)
                    // If hitting from Down (dir 0), go Right (dir 3)
                    // Mapping: 0->1, 1->0, 2->3, 3->2
                    if(cdir === 0) cdir = 1;
                    else if(cdir === 1) cdir = 0;
                    else if(cdir === 2) cdir = 3;
                    else if(cdir === 3) cdir = 2;
                }
                else if(grid[cy][cx] === 3) { // Mirror \
                    playSound('reflect');
                    // Mapping: 0->3, 1->2, 2->1, 3->0
                    if(cdir === 0) cdir = 3;
                    else if(cdir === 1) cdir = 2;
                    else if(cdir === 2) cdir = 1;
                    else if(cdir === 3) cdir = 0;
                }

                if(!active) {
                    clearInterval(traceInterval);
                    if(!(cx === target.x && cy === target.y)) {
                        // Failed
                        setTimeout(() => {
                            isFiring = false;
                            laserPath = []; // Clear beam
                            draw();
                        }, 1000);
                    }
                }

            }, 50); // Speed of laser
        }

        function winLevel() {
            playSound('success');
            document.getElementById('message-overlay').style.display = 'block';
            setTimeout(() => {
                level++;
                document.getElementById('level-display').innerText = level;
                generateLevel();
                draw();
            }, 2000);
        }

        // --- Rendering ---
        function draw() {
            // Clear
            ctx.fillStyle = '#0a0d14';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw Grid Lines
            ctx.strokeStyle = '#1f2937';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let i=0; i<=GRID_SIZE; i++) {
                ctx.moveTo(i*CELL_SIZE, 0); ctx.lineTo(i*CELL_SIZE, canvas.height);
                ctx.moveTo(0, i*CELL_SIZE); ctx.lineTo(canvas.width, i*CELL_SIZE);
            }
            ctx.stroke();

            // Draw Items
            for(let y=0; y<GRID_SIZE; y++) {
                for(let x=0; x<GRID_SIZE; x++) {
                    const cx = x * CELL_SIZE + CELL_SIZE/2;
                    const cy = y * CELL_SIZE + CELL_SIZE/2;

                    if(grid[y][x] === 1) { // Wall
                        ctx.fillStyle = '#334155';
                        ctx.fillRect(x*CELL_SIZE + 2, y*CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
                        ctx.fillStyle = '#1e293b';
                        ctx.fillRect(x*CELL_SIZE + 10, y*CELL_SIZE + 10, CELL_SIZE - 20, CELL_SIZE - 20);
                    }
                    else if(grid[y][x] === 2) { // Mirror /
                        drawMirror(cx, cy, '/');
                    }
                    else if(grid[y][x] === 3) { // Mirror \
                        drawMirror(cx, cy, '\\');
                    }
                }
            }

            // Draw Source & Target
            drawDevice(source.x, source.y, 'source', source.dir);
            drawDevice(target.x, target.y, 'target');

            // Draw Laser Path
            if(laserPath.length > 0) {
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#00ff41';
                ctx.strokeStyle = '#00ff41';
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                // Start at source center
                ctx.moveTo(source.x * CELL_SIZE + CELL_SIZE/2, source.y * CELL_SIZE + CELL_SIZE/2);
                
                laserPath.forEach(p => {
                    // Clamp drawing to grid center points for visual cleanliness
                    // but clamping visualization slightly to avoid overshooting walls visually
                    ctx.lineTo(p.x * CELL_SIZE + CELL_SIZE/2, p.y * CELL_SIZE + CELL_SIZE/2);
                });
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
        }

        function drawMirror(cx, cy, type) {
            ctx.save();
            ctx.translate(cx, cy);
            
            // Glow
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00f3ff';
            
            ctx.strokeStyle = '#00f3ff';
            ctx.lineWidth = 4;
            ctx.beginPath();
            if(type === '/') {
                ctx.moveTo(20, -20);
                ctx.lineTo(-20, 20);
            } else {
                ctx.moveTo(-20, -20);
                ctx.lineTo(20, 20);
            }
            ctx.stroke();
            
            // Backing
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            ctx.restore();
        }

        function drawDevice(x, y, type, dir=0) {
            const cx = x * CELL_SIZE + CELL_SIZE/2;
            const cy = y * CELL_SIZE + CELL_SIZE/2;
            
            ctx.save();
            ctx.translate(cx, cy);
            
            const color = type === 'source' ? '#00ff41' : '#ff003c';
            ctx.fillStyle = color;
            ctx.shadowBlur = 15;
            ctx.shadowColor = color;

            // Base Circle
            ctx.beginPath();
            ctx.arc(0, 0, 15, 0, Math.PI*2);
            ctx.fill();

            // Direction Indicator (only for source)
            if(type === 'source') {
                ctx.rotate(dir * Math.PI / 2);
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.moveTo(-5, -5);
                ctx.lineTo(0, -15); // Pointing Up (relative)
                ctx.lineTo(5, -5);
                ctx.fill();
            } else {
                // Target Core
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(0, 0, 6, 0, Math.PI*2);
                ctx.fill();
            }

            ctx.restore();
        }

        // Start
        initGame();

    </script>
</body>
</html>