<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Super Conductor: Overload</title>
    <style>
        :root {
            --bg-color: #050510;
            --wire-color: #1a1a2e;
            --neon-blue: #00f3ff;
            --neon-red: #ff0055;
            --neon-yellow: #ffe600;
            --ui-bg: rgba(20, 20, 40, 0.9);
        }
        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
            touch-action: none;
        }
        
        #ui-layer {
            position: absolute;
            top: 20px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 20px;
            z-index: 10;
            pointer-events: none;
        }
        
        .stat-panel {
            background: var(--ui-bg);
            border: 2px solid var(--neon-blue);
            padding: 10px 20px;
            border-radius: 5px;
            box-shadow: 0 0 10px var(--neon-blue);
            text-align: center;
            min-width: 100px;
            transition: transform 0.1s;
        }
        .stat-label { font-size: 0.8rem; color: #aaa; }
        .stat-value { font-size: 1.5rem; font-weight: bold; }
        
        #game-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            height: 100vh;
            background: #0a0a15;
            border-left: 2px solid #333;
            border-right: 2px solid #333;
            box-shadow: 0 0 50px rgba(0, 243, 255, 0.1);
            overflow: hidden;
        }
        
        canvas { display: block; width: 100%; height: 100%; }

        .overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            text-align: center;
        }
        .overlay h1 {
            color: var(--neon-blue);
            font-size: 2.5rem;
            text-shadow: 0 0 20px var(--neon-blue);
            margin-bottom: 10px;
        }
        .overlay p { margin: 10px 20px; line-height: 1.5; max-width: 80%; }
        
        .btn {
            margin-top: 30px;
            background: transparent;
            color: var(--neon-yellow);
            border: 2px solid var(--neon-yellow);
            padding: 15px 40px;
            font-size: 1.2rem;
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            transition: 0.2s;
            box-shadow: 0 0 10px var(--neon-yellow);
        }
        .btn:hover {
            background: var(--neon-yellow);
            color: #000;
            box-shadow: 0 0 30px var(--neon-yellow);
        }
        
        .edu-tip {
            color: #ccc;
            font-size: 0.9rem;
            margin-top: 20px;
            border-top: 1px solid #555;
            padding-top: 10px;
        }

        #touch-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 50%;
            display: flex;
            z-index: 5;
        }
        .touch-zone { flex: 1; }

        /* Floating Text Animation */
        .float-text {
            position: absolute;
            color: #fff;
            font-weight: bold;
            font-size: 2rem;
            pointer-events: none;
            animation: floatUp 1s forwards;
            text-shadow: 2px 2px 0 #000;
            z-index: 15;
            width: 100%;
            text-align: center;
            left: 0;
        }
        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            50% { transform: translateY(-20px) scale(1.2); opacity: 1; }
            100% { transform: translateY(-50px) scale(1); opacity: 0; }
        }

    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="stat-panel">
            <div class="stat-label">DISTANCE</div>
            <div class="stat-value" id="score-display">0m</div>
        </div>
        <div class="stat-panel" id="energy-panel">
            <div class="stat-label">VOLTAGE</div>
            <div class="stat-value" id="energy-display">100%</div>
        </div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div id="touch-controls">
            <div class="touch-zone" id="left-zone"></div>
            <div class="touch-zone" id="right-zone"></div>
        </div>

        <div id="start-screen" class="overlay">
            <h1>SUPER CONDUCTOR</h1>
            <p>You are an <strong>Electron</strong>.</p>
            <p style="color: var(--neon-red)">Avoid Resistors</p>
            <p style="color: var(--neon-yellow)">Collect Batteries</p>
            <p style="font-size: 0.9rem; color: #aaa;">(Game speeds up over time!)</p>
            <button class="btn" onclick="startGame()">Start Circuit</button>
        </div>

        <div id="game-over-screen" class="overlay" style="display: none;">
            <h1 style="color: var(--neon-red)">CIRCUIT BROKEN</h1>
            <p>You ran out of Voltage.</p>
            <p>Final Distance: <span id="final-score" style="color: #fff; font-weight: bold;">0</span>m</p>
            <button class="btn" onclick="startGame()">Recharge & Retry</button>
            <div class="edu-tip" id="loss-tip">Resistance creates heat and slows down electrons!</div>
        </div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('game-container');
    
    function resize() {
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- Audio ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();

    function playSound(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        const now = audioCtx.currentTime;

        if (type === 'move') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(600, now);
            osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.start(now);
            osc.stop(now + 0.1);
        } else if (type === 'battery') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(440, now);
            osc.frequency.linearRampToValueAtTime(880, now + 0.1);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
            osc.start(now);
            osc.stop(now + 0.2);
        } else if (type === 'hit') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.linearRampToValueAtTime(50, now + 0.2);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
            osc.start(now);
            osc.stop(now + 0.2);
        } else if (type === 'levelup') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.linearRampToValueAtTime(600, now + 0.3);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
            osc.start(now);
            osc.stop(now + 0.5);
        }
    }

    // --- Game Variables ---
    const LANES = 3;
    const PLAYER_SIZE = 20;
    let state = {
        running: false,
        lane: 1, 
        score: 0,
        energy: 100,
        speed: 6,
        obstacles: [], 
        particles: [],
        tick: 0
    };

    // --- Controls ---
    function moveLeft() {
        if (!state.running) return;
        if (state.lane > 0) {
            state.lane--;
            playSound('move');
        }
    }
    function moveRight() {
        if (!state.running) return;
        if (state.lane < LANES - 1) {
            state.lane++;
            playSound('move');
        }
    }
    document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft' || e.key === 'a') moveLeft();
        if (e.key === 'ArrowRight' || e.key === 'd') moveRight();
    });
    document.getElementById('left-zone').addEventListener('mousedown', (e) => { e.preventDefault(); moveLeft(); });
    document.getElementById('right-zone').addEventListener('mousedown', (e) => { e.preventDefault(); moveRight(); });
    // Touch support
    document.getElementById('left-zone').addEventListener('touchstart', (e) => { e.preventDefault(); moveLeft(); });
    document.getElementById('right-zone').addEventListener('touchstart', (e) => { e.preventDefault(); moveRight(); });

    // --- Game Logic ---
    function startGame() {
        document.getElementById('start-screen').style.display = 'none';
        document.getElementById('game-over-screen').style.display = 'none';
        
        state = {
            running: true,
            lane: 1,
            score: 0,
            energy: 100,
            speed: 5, // Starting speed
            obstacles: [],
            particles: [],
            tick: 0
        };
        gameLoop();
    }

    function gameOver() {
        state.running = false;
        playSound('hit');
        document.getElementById('final-score').innerText = Math.floor(state.score);
        document.getElementById('game-over-screen').style.display = 'flex';
    }

    function showFloatingText(text, color) {
        const div = document.createElement('div');
        div.className = 'float-text';
        div.innerText = text;
        div.style.color = color;
        div.style.top = '40%';
        container.appendChild(div);
        setTimeout(() => div.remove(), 1000);
    }

    function spawnObstacle() {
        // Difficulty Logic:
        // < 1000 score: Single obstacles
        // > 1000 score: Chance for double obstacles (block 2 lanes)
        
        const isHardMode = state.score > 150 && Math.random() < 0.4; // 40% chance of double block after 150m

        if (isHardMode) {
            // Spawn Double Block
            const safeLane = Math.floor(Math.random() * LANES);
            for (let l = 0; l < LANES; l++) {
                if (l !== safeLane) {
                    state.obstacles.push({
                        type: 'resistor',
                        lane: l,
                        y: -100,
                        active: true,
                        rotation: 0
                    });
                }
            }
        } else {
            // Standard Spawn
            const type = Math.random() < 0.3 ? 'battery' : 'resistor';
            const lane = Math.floor(Math.random() * LANES);
            state.obstacles.push({
                type: type,
                lane: lane,
                y: -100,
                active: true,
                rotation: 0
            });
        }
    }

    function createParticles(x, y, color, count) {
        for(let i=0; i<count; i++) {
            state.particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                life: 1.0,
                color: color
            });
        }
    }

    function gameLoop() {
        if (!state.running) return;

        state.tick++;
        state.score += state.speed / 20;

        // --- DIFFICULTY RAMPS ---
        // 1. Speed Up every 300 ticks (approx 5 seconds)
        if (state.tick % 300 === 0) {
            state.speed += 0.8;
            playSound('levelup');
            showFloatingText("SPEED UP!", "#00f3ff");
        }

        // 2. Energy Drain (Faster speed = Higher resistance/drain)
        // Base drain + speed penalty
        let drainRate = 0.15 + (state.speed * 0.015); 
        if (state.tick % 10 === 0) state.energy -= drainRate;
        
        if (state.energy <= 0) gameOver();

        // 3. Spawn Rate (Gets faster as speed increases to keep density)
        // Formula: As speed goes up, spawn interval goes down
        let spawnInterval = Math.max(25, 60 - (state.speed * 2));
        if (state.tick % Math.floor(spawnInterval) === 0) {
            spawnObstacle();
        }

        // --- UPDATE OBSTACLES ---
        for (let i = state.obstacles.length - 1; i >= 0; i--) {
            let obs = state.obstacles[i];
            obs.y += state.speed;
            obs.rotation += 0.1;

            // Collision
            const playerY = canvas.height - 100;
            const laneWidth = canvas.width / LANES;
            const obsX = (obs.lane * laneWidth) + (laneWidth / 2);

            // Hitbox: Simple distance check, vertical range
            if (obs.active && 
                obs.lane === state.lane && 
                Math.abs(obs.y - playerY) < 35) {
                
                if (obs.type === 'resistor') {
                    playSound('hit');
                    state.energy -= 30; // Big penalty
                    state.speed = Math.max(5, state.speed - 3); // Slow down significantly
                    createParticles(obsX, obs.y, '#ff0055', 15);
                    obs.active = false;
                    showFloatingText("RESISTANCE!", "#ff0055");
                } else if (obs.type === 'battery') {
                    playSound('battery');
                    state.energy = Math.min(100, state.energy + 20);
                    createParticles(obsX, obs.y, '#ffe600', 10);
                    obs.active = false;
                }
            }

            if (obs.y > canvas.height + 50) state.obstacles.splice(i, 1);
        }

        // --- UPDATE PARTICLES ---
        for (let i = state.particles.length - 1; i >= 0; i--) {
            let p = state.particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.05;
            if (p.life <= 0) state.particles.splice(i, 1);
        }

        draw();
        updateUI();
        requestAnimationFrame(gameLoop);
    }

    function draw() {
        ctx.fillStyle = '#050510';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        const laneWidth = canvas.width / LANES;

        // Grid / Motion Blur lines
        ctx.strokeStyle = '#1a1a2e';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for(let i=1; i<LANES; i++) {
            ctx.moveTo(i * laneWidth, 0);
            ctx.lineTo(i * laneWidth, canvas.height);
        }
        // Speed lines
        const offset = (state.tick * state.speed * 2) % 100;
        for(let y = offset; y < canvas.height; y += 100) {
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
        }
        ctx.stroke();

        // Draw Player
        const playerX = (state.lane * laneWidth) + (laneWidth / 2);
        const playerY = canvas.height - 100;
        
        // Tail/Trail effect
        ctx.fillStyle = 'rgba(0, 243, 255, 0.3)';
        ctx.beginPath();
        ctx.arc(playerX, playerY + 10, PLAYER_SIZE * 0.8, 0, Math.PI*2);
        ctx.fill();

        ctx.shadowBlur = 20;
        ctx.shadowColor = '#00f3ff';
        ctx.fillStyle = '#00f3ff';
        ctx.beginPath();
        ctx.arc(playerX, playerY, PLAYER_SIZE, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(playerX, playerY, PLAYER_SIZE/2, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Draw Obstacles
        state.obstacles.forEach(obs => {
            if (!obs.active) return;
            const obsX = (obs.lane * laneWidth) + (laneWidth / 2);
            
            if (obs.type === 'resistor') {
                ctx.strokeStyle = '#ff0055';
                ctx.lineWidth = 6;
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ff0055';
                ctx.beginPath();
                // ZigZag
                ctx.moveTo(obsX - 25, obs.y - 20);
                ctx.lineTo(obsX + 25, obs.y - 10);
                ctx.lineTo(obsX - 25, obs.y + 10);
                ctx.lineTo(obsX + 25, obs.y + 20);
                ctx.stroke();
                ctx.shadowBlur = 0;
            } else {
                ctx.fillStyle = '#ffe600';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffe600';
                ctx.font = "45px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("âš¡", obsX, obs.y);
                ctx.shadowBlur = 0;
            }
        });

        // Draw Particles
        state.particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        });
    }

    function updateUI() {
        document.getElementById('score-display').innerText = Math.floor(state.score) + "m";
        const eDisp = document.getElementById('energy-display');
        eDisp.innerText = Math.floor(state.energy) + "%";
        
        const panel = document.getElementById('energy-panel');
        if (state.energy < 30) {
            eDisp.style.color = '#ff0055';
            panel.style.borderColor = '#ff0055';
            panel.style.boxShadow = '0 0 20px #ff0055';
        } else {
            eDisp.style.color = '#fff';
            panel.style.borderColor = '#ffe600';
            panel.style.boxShadow = '0 0 10px #ffe600';
        }
    }

</script>
</body>
</html>